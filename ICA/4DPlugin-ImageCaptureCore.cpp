/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ImageCaptureCore.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ImageCaptureCore
 #	author : miyako
 #	2020/03/04
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ImageCaptureCore.h"

#pragma mark Utility

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

std::mutex globalMutex; /* for callback params */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* for PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* for PROCESS_SHOULD_RESUME */

#pragma mark Browser
namespace Scan
{
    //globals
    ICDeviceBrowser *deviceBrowser = nil;
    ScannerBrowser *deviceBrowserDelegate = nil;
    Scanner *device = nil;
    
    param_scan_context_info_t CALLBACK_METHOD_CONTEXT_INFO;
    
    process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
//    method_id_t CALLBACK_METHOD_ID = 0;

    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t MONITOR_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;

    //constant
    process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0S\0C\0A\0N\0N\0E\0R\0\0\0";

    //callback params
    std::vector<param_scan_path_t>CALLBACK_PARAMS_SCAN_PATH;
    std::vector<param_scan_type_t>CALLBACK_PARAMS_SCAN_TYPE;
    std::vector<param_scan_data_t>CALLBACK_PARAMS_SCAN_DATA;
    std::vector<param_scan_info_t>CALLBACK_PARAMS_SCAN_INFO;
    
    void startDeviceBrowser()
    {
        Scan::deviceBrowserDelegate = [[ScannerBrowser alloc]init];
        Scan::deviceBrowser = [[ICDeviceBrowser alloc]init];
        Scan::deviceBrowser.delegate = Scan::deviceBrowserDelegate;
        Scan::deviceBrowser.browsedDeviceTypeMask = static_cast<ICDeviceTypeMask>(ICDeviceAnyScanner);
        [Scan::deviceBrowser start];
        
        Scan::device = [[Scanner alloc]init];
    }
    
    void stopDeviceBrowser()
    {
        
        // important! this is not the time to dispatch new objc messages
        // [Scan::deviceBrowser stop];
        
        Scan::deviceBrowser.delegate = nil;
        [Scan::deviceBrowser release];
        
        [Scan::deviceBrowserDelegate release];
        [Scan::device release];
    }
    
#pragma mark -
    
#pragma mark API
    
    void setMethod(C_TEXT &context_info)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);

            CALLBACK_METHOD_CONTEXT_INFO = CUTF16String(context_info.getUTF16StringPtr(), context_info.getUTF16Length());
        }
    }
    
    void cleanupWithTimeout(NSUInteger seconds)
    {
        NSArray *scanners = [deviceBrowserDelegate scanners];
        for(NSUInteger i = 0;i < [scanners count];++i)
        {
            ICScannerDevice *scanner = (ICScannerDevice *)[scanners objectAtIndex:i];
            if([scanner hasOpenSession])
            {
                @autoreleasepool
                {
                    NSTimeInterval end = [NSDate timeIntervalSinceReferenceDate] + seconds;
                    [scanner requestCloseSession];
                    do {
                        PA_YieldAbsolute();
                    } while ([scanner hasOpenSession] && ([NSDate timeIntervalSinceReferenceDate] < end));
                }
            }//
        }//scanners
    }

bool convert_text_to_path(NSString *value, std::string &str) {
    
    bool status = false;
    
    if(value)
    {
        NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)value, kCFURLPOSIXPathStyle, false);
        if(u)
        {
            NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLHFSPathStyle);
            str = [path UTF8String];
            [path release];
            [u release];
            
             status = true;
        }
    }
    
    return status;
}

bool convert_path_to_path(NSURL *u, std::string &str) {
    
    bool status = false;
    
    if(u)
    {
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLHFSPathStyle);
        
        if(path) {
            
            if(![path hasSuffix:@":"])
            {
                str = [[path stringByAppendingString:@":"] UTF8String];
            }else
            {
                str = [path UTF8String];
            }
            
            [path release];
            
            status = true;
        }
    }
    
    return status;
}

    void getScanners(ARRAY_TEXT &devices)
    {
        NSArray *scanners = [deviceBrowserDelegate scanners];
        
        devices.setSize(1);
        
        Json::Value json_scanners = Json::Value(Json::arrayValue);
                
        for(NSUInteger i = 0;i < [scanners count];++i)
        {
            ICScannerDevice *scanner = (ICScannerDevice *)[scanners objectAtIndex:i];
            devices.appendUTF16String([scanner UUIDString]);
                        
            Json::Value json_scanner;
            //ICDevice, NSString
                        
            NSString *_name = [scanner name];
            json_scanner["name"] = _name ? [_name UTF8String] : Json::Value::null;
            
            std::string modulePath;
            if(convert_text_to_path([scanner modulePath], modulePath)) {
                json_scanner["modulePath"] = modulePath;
            }else{
                json_scanner["iconPath"] = Json::Value::null;
            }
            
            std::string iconPath;
            if(convert_text_to_path([scanner performSelector:@selector(iconPath)], iconPath)) {
                json_scanner["iconPath"] = iconPath;
            }else{
                json_scanner["iconPath"] = Json::Value::null;
            }

            NSString *_moduleVersion = [[scanner moduleVersion]
                                        stringByReplacingOccurrencesOfString:@"\n"
                                        withString:@""];//contains LF (hp Officejet Pro 8600)

            json_scanner["moduleVersion"] = _moduleVersion ? [_moduleVersion UTF8String] : Json::Value::null;
            
            NSString *_autolaunchApplicationPath = [scanner autolaunchApplicationPath];
            json_scanner["autolaunchApplicationPath"] = _autolaunchApplicationPath ? [_autolaunchApplicationPath UTF8String] : Json::Value::null;
            
            NSString *_persistentIDString = [scanner persistentIDString];
            json_scanner["persistentIDString"] = _persistentIDString ? [_persistentIDString UTF8String] : Json::Value::null;
            
            NSString *_UUIDString = [scanner UUIDString];
            json_scanner["UUIDString"] = _UUIDString ? [_UUIDString UTF8String] : Json::Value::null;
            
            NSString *_locationDescription = [scanner locationDescription];
            json_scanner["locationDescription"] = _locationDescription ? [_locationDescription UTF8String] : Json::Value::null;
 
            NSString *_serialNumberString = [scanner serialNumberString];
            json_scanner["serialNumberString"] = _serialNumberString ? [_serialNumberString UTF8String] : Json::Value::null;

            NSString *_transportType = [scanner transportType];
            json_scanner["transportType"] = _transportType ? [_transportType UTF8String] : Json::Value::null;
 
            //ICDevice, hidden
            //https://github.com/pombredanne/osx_headers/blob/master/Frameworks/ImageCaptureCore/ICDevice.h
            NSString *_ipAddress = [scanner performSelector:@selector(ipAddress)];
            json_scanner["ipAddress"] = _ipAddress ? [_ipAddress UTF8String] : Json::Value::null;
            
            //ICDevice, BOOL
            json_scanner["isRemote"] = [scanner isRemote];
        
//            json_scanner["isShared"] = [scanner isShared];
//            json_scanner["hasConfigurableWiFiInterface"] = [scanner hasConfigurableWiFiInterface];

            json_scanner["hasOpenSession"] = [scanner hasOpenSession];
            
            //ICDevice, int
            json_scanner["usbVendorID"] = [scanner usbVendorID];
            json_scanner["usbProductID"] = [scanner usbProductID];
            json_scanner["usbLocationID"] = [scanner usbLocationID];
            json_scanner["moduleExecutableArchitecture"] = [scanner moduleExecutableArchitecture];
            
            //ICScannerDevice, NSString
            json_scanner["documentName"] = [scanner documentName];
            json_scanner["documentUTI"] = [scanner documentUTI];
            
            //convert to hfs path
            std::string downloadsDirectory;

            if(convert_path_to_path([scanner downloadsDirectory], downloadsDirectory)) {
                json_scanner["downloadsDirectory"] = downloadsDirectory;
            }else{
                json_scanner["downloadsDirectory"] = Json::Value::null;
            }
            
            switch ([scanner transferMode]) {
                case ICScannerTransferModeFileBased:
                    json_scanner["transferMode"] = "ICScannerTransferModeFileBased";
                    break;
                case ICScannerTransferModeMemoryBased:
                    json_scanner["transferMode"] = "ICScannerTransferModeMemoryBased";
                    break;
                default:
                    break;
            };
            
            //ICScannerDevice, UInt32
            json_scanner["maxMemoryBandSize"] = [scanner maxMemoryBandSize];
            
            //ICScannerFunctionalUnit
            ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
            
            //session needs to be open
            if(currentFunctionalUnit)
            {
                //ICScannerFunctionalUnit, NSIndexSet<ICScannerBitDepth>
                __block Json::Value json_supportedBitDepths = Json::Value(Json::arrayValue);
                
                NSIndexSet *supportedBitDepths = currentFunctionalUnit.supportedBitDepths;
                [supportedBitDepths enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                     switch ((ICScannerBitDepth)idx)
                     {
                         case ICScannerBitDepth1Bit:
                             json_supportedBitDepths.append("ICScannerBitDepth1Bit");
                             break;
                         case ICScannerBitDepth8Bits:
                             json_supportedBitDepths.append("ICScannerBitDepth8Bits");
                             break;
                         case ICScannerBitDepth16Bits:
                             json_supportedBitDepths.append("ICScannerBitDepth16Bits");
                             break;
                         default:
                             break;
                     }
                 }];
                
                json_scanner["supportedBitDepths"] = json_supportedBitDepths;
                                
                //ICScannerFunctionalUnit, NSIndexSet<ICScannerMeasurementUnit>
                
                __block Json::Value json_supportedMeasurementUnits = Json::Value(Json::arrayValue);
                
                NSIndexSet *supportedMeasurementUnits = currentFunctionalUnit.supportedMeasurementUnits;
                [supportedMeasurementUnits enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                     switch ((ICScannerMeasurementUnit)idx)
                     {
                         case ICScannerMeasurementUnitInches:
                             json_supportedMeasurementUnits.append("ICScannerMeasurementUnitInches");
                              break;
                         case ICScannerMeasurementUnitCentimeters:
                             json_supportedMeasurementUnits.append("ICScannerMeasurementUnitCentimeters");
                              break;
                         case ICScannerMeasurementUnitPicas:
                             json_supportedMeasurementUnits.append("ICScannerMeasurementUnitPicas");
                             break;
                         case ICScannerMeasurementUnitPoints:
                              json_supportedMeasurementUnits.append("ICScannerMeasurementUnitPoints");
                               break;
                         case ICScannerMeasurementUnitTwips:
                             json_supportedMeasurementUnits.append("ICScannerMeasurementUnitTwips");
                              break;
                         case ICScannerMeasurementUnitPixels:
                             json_supportedMeasurementUnits.append("ICScannerMeasurementUnitPixels");
                             break;
                         default:
                             break;
                     }
                 }];
                
                json_scanner["supportedMeasurementUnits"] = json_supportedMeasurementUnits;
                
                //ICScannerFunctionalUnit, NSIndexSet<NSUInteger>
                __block Json::Value json_preferredResolutions = Json::Value(Json::arrayValue);

                NSIndexSet *preferredResolutions = currentFunctionalUnit.preferredResolutions;
                [preferredResolutions enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                    json_preferredResolutions.append((unsigned int)idx);
                 }];
                
                json_scanner["preferredResolutions"] = json_preferredResolutions;
                
                __block Json::Value json_supportedResolutions = Json::Value(Json::arrayValue);

                NSIndexSet *supportedResolutions = currentFunctionalUnit.supportedResolutions;
                [supportedResolutions enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                    json_supportedResolutions.append((unsigned int)idx);
                 }];
                
                json_scanner["supportedResolutions"] = json_supportedResolutions;
                
                __block Json::Value json_preferredScaleFactors = Json::Value(Json::arrayValue);

                NSIndexSet *preferredScaleFactors = currentFunctionalUnit.preferredScaleFactors;
                [preferredScaleFactors enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                    json_preferredScaleFactors.append((unsigned int)idx);
                 }];
                
                json_scanner["preferredScaleFactors"] = json_preferredScaleFactors;
                
                __block Json::Value json_supportedScaleFactors = Json::Value(Json::arrayValue);
                
                NSIndexSet *supportedScaleFactors = currentFunctionalUnit.supportedScaleFactors;
                [supportedScaleFactors enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                 {
                    json_supportedScaleFactors.append((unsigned int)idx);
                 }];
                
                json_scanner["supportedScaleFactors"] = json_supportedScaleFactors;
                                
                //ICScannerFunctionalUnit, ICScannerMeasurementUnit
                switch (currentFunctionalUnit.measurementUnit) {
                    case ICScannerMeasurementUnitInches:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitInches";
                        break;
                    case ICScannerMeasurementUnitCentimeters:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitCentimeters";
                        break;
                    case ICScannerMeasurementUnitPicas:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitPicas";
                        break;
                    case ICScannerMeasurementUnitPoints:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitPoints";
                        break;
                    case ICScannerMeasurementUnitTwips:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitTwips";
                        break;
                    case ICScannerMeasurementUnitPixels:
                        json_scanner["measurementUnit"] = "ICScannerMeasurementUnitPixels";
                        break;
                    default:
                        break;
                };
                
                //ICScannerFunctionalUnit, ICScannerPixelDataType
                switch (currentFunctionalUnit.pixelDataType) {
                    case ICScannerPixelDataTypeBW:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeBW";
                        break;
                    case ICScannerPixelDataTypeGray:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeGray";
                        break;
                    case ICScannerPixelDataTypeRGB:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeRGB";
                        break;
                    case ICScannerPixelDataTypePalette:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypePalette";
                        break;
                    case ICScannerPixelDataTypeCMY:
                         json_scanner["pixelDataType"] = "ICScannerPixelDataTypeCMY";
                        break;
                    case ICScannerPixelDataTypeCMYK:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeCMYK";
                        break;
                    case ICScannerPixelDataTypeYUV:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeYUV";
                        break;
                    case ICScannerPixelDataTypeYUVK:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeYUVK";
                        break;
                    case ICScannerPixelDataTypeCIEXYZ:
                        json_scanner["pixelDataType"] = "ICScannerPixelDataTypeCIEXYZ";
                        break;
                    default:
                        break;
                };
                
                //ICScannerFunctionalUnit, ICScannerBitDepth
                switch (currentFunctionalUnit.bitDepth) {
                    case ICScannerBitDepth1Bit:
                        json_scanner["bitDepth"] = "ICScannerBitDepth1Bit";
                        break;
                    case ICScannerBitDepth8Bits:
                        json_scanner["bitDepth"] = "ICScannerBitDepth8Bits";
                        break;
                    case ICScannerBitDepth16Bits:
                        json_scanner["bitDepth"] = "ICScannerBitDepth16Bits";
                        break;
                    default:
                        break;
                };
                
                //ICScannerFunctionalUnit, NSSize
                NSSize physicalSize = currentFunctionalUnit.physicalSize;
                
                Json::Value json_physicalSize;
                json_physicalSize["width"] = physicalSize.width;
                json_physicalSize["height"] = physicalSize.height;
                json_scanner["physicalSize"] = json_physicalSize;
                
                //ICScannerFunctionalUnit, NSRect
                NSRect scanArea = currentFunctionalUnit.scanArea;
                
                Json::Value json_scanArea;
                json_scanArea["x"] = scanArea.origin.x;
                json_scanArea["y"] = scanArea.origin.y;
                json_scanArea["width"] = scanArea.size.width;
                json_scanArea["height"] = scanArea.size.height;
                json_scanner["scanArea"] = json_scanArea;

                //ICScannerFunctionalUnit, CGFloat
                json_scanner["scanProgressPercentDone"] = currentFunctionalUnit.scanProgressPercentDone;
                
                //ICScannerFunctionalUnit, NSUInteger
                json_scanner["resolution"] = (unsigned int)currentFunctionalUnit.resolution;
                json_scanner["nativeXResolution"] = (unsigned int)currentFunctionalUnit.nativeXResolution;
                json_scanner["nativeYResolution"] = (unsigned int)currentFunctionalUnit.nativeYResolution;
                json_scanner["overviewResolution"] = (unsigned int)currentFunctionalUnit.overviewResolution;
                json_scanner["scaleFactor"] = (unsigned int)currentFunctionalUnit.scaleFactor;
                                
                //ICScannerFunctionalUnit, unsigned char
                json_scanner["thresholdForBlackAndWhiteScanning"] = currentFunctionalUnit.thresholdForBlackAndWhiteScanning;
                json_scanner["defaultThresholdForBlackAndWhiteScanning"] = currentFunctionalUnit.defaultThresholdForBlackAndWhiteScanning;
       
                //ICScannerFunctionalUnit, BOOL
                json_scanner["overviewScanInProgress"] = currentFunctionalUnit.overviewScanInProgress;
                json_scanner["canPerformOverviewScan"] = currentFunctionalUnit.canPerformOverviewScan;
                json_scanner["scanInProgress"] = currentFunctionalUnit.scanInProgress;
                json_scanner["acceptsThresholdForBlackAndWhiteScanning"] = currentFunctionalUnit.acceptsThresholdForBlackAndWhiteScanning;
                json_scanner["usesThresholdForBlackAndWhiteScanning"] = currentFunctionalUnit.usesThresholdForBlackAndWhiteScanning;
                
                switch (currentFunctionalUnit.type) {
                    case ICScannerFunctionalUnitTypeFlatbed:
                    case ICScannerFunctionalUnitTypeDocumentFeeder:
                    case ICScannerFunctionalUnitTypeNegativeTransparency:
                    case ICScannerFunctionalUnitTypePositiveTransparency:
                    {
                        /*
                         all document types
                         @property supportedDocumentTypes
                         @property documentType
                         @property documentSize
                         */
                        
                        //NSSize
                        NSSize documentSize = ((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentSize;
                        
                        Json::Value json_documentSize;
                        json_documentSize["width"] = documentSize.width;
                        json_documentSize["height"] = documentSize.height;
                        json_scanner["documentSize"] = json_documentSize;
                                                
                        //ICScannerDocumentType
                        switch (((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType) {
                            case ICScannerDocumentTypeDefault:
                                json_scanner["documentType"] = "ICScannerDocumentTypeDefault";
                                break;
                            case ICScannerDocumentTypeA4:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA4";
                                break;
                            case ICScannerDocumentTypeB5:
                                json_scanner["documentType"] = "ICScannerDocumentTypeB5";
                                break;
                            case ICScannerDocumentTypeUSLetter:
                                json_scanner["documentType"] = "ICScannerDocumentTypeUSLetter";
                                break;
                            case ICScannerDocumentTypeUSLegal:
                                json_scanner["documentType"] = "ICScannerDocumentTypeUSLegal";
                                break;
                            case ICScannerDocumentTypeA5:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA5";
                                break;
                            case ICScannerDocumentTypeISOB4:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB4";
                                break;
                            case ICScannerDocumentTypeISOB6:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB6";
                                break;
                            case ICScannerDocumentTypeUSLedger:
                                json_scanner["documentType"] = "ICScannerDocumentTypeUSLedger";
                                break;
                            case ICScannerDocumentTypeUSExecutive:
                                json_scanner["documentType"] = "ICScannerDocumentTypeUSExecutive";
                                break;
                            case ICScannerDocumentTypeA3:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA3";
                                break;
                            case ICScannerDocumentTypeISOB3:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB3";
                                break;
                            case ICScannerDocumentTypeA6:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA6";
                                break;
                            case ICScannerDocumentTypeC4:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC4";
                                break;
                            case ICScannerDocumentTypeC5:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC5";
                                break;
                            case ICScannerDocumentTypeC6:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC6";
                                break;
                            case ICScannerDocumentType4A0:
                                json_scanner["documentType"] = "ICScannerDocumentType4A0";
                                break;
                            case ICScannerDocumentType2A0:
                                json_scanner["documentType"] = "ICScannerDocumentType2A0";
                                break;
                            case ICScannerDocumentTypeA0:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA0";
                                break;
                            case ICScannerDocumentTypeA1:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA1";
                                break;
                            case ICScannerDocumentTypeA2:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA2";
                                break;
                            case ICScannerDocumentTypeA7:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA7";
                                break;
                            case ICScannerDocumentTypeA8:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA8";
                                break;
                            case ICScannerDocumentTypeA9:
                                json_scanner["documentType"] = "ICScannerDocumentTypeA9";
                                break;
                            case ICScannerDocumentType10:
                                json_scanner["documentType"] = "ICScannerDocumentType10";
                                break;
                            case ICScannerDocumentTypeISOB0:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB0";
                                break;
                            case ICScannerDocumentTypeISOB1:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB1";
                                break;
                            case ICScannerDocumentTypeISOB2:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB2";
                                break;
                            case ICScannerDocumentTypeISOB5:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB5";
                                break;
                            case ICScannerDocumentTypeISOB7:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB7";
                                break;
                            case ICScannerDocumentTypeISOB8:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB8";
                                break;
                            case ICScannerDocumentTypeISOB9:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB9";
                                break;
                            case ICScannerDocumentTypeISOB10:
                                json_scanner["documentType"] = "ICScannerDocumentTypeISOB10";
                                break;
                            case ICScannerDocumentTypeJISB0:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB0";
                                break;
                            case ICScannerDocumentTypeJISB1:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB1";
                                break;
                            case ICScannerDocumentTypeJISB2:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB2";
                                break;
                            case ICScannerDocumentTypeJISB3:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB3";
                                break;
                            case ICScannerDocumentTypeJISB4:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB4";
                                break;
                            case ICScannerDocumentTypeJISB6:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB6";
                                break;
                            case ICScannerDocumentTypeJISB7:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB7";
                                break;
                            case ICScannerDocumentTypeJISB8:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB8";
                                break;
                            case ICScannerDocumentTypeJISB9:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB9";
                                break;
                            case ICScannerDocumentTypeJISB10:
                                json_scanner["documentType"] = "ICScannerDocumentTypeJISB10";
                                break;
                            case ICScannerDocumentTypeC0:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC0";
                                break;
                            case ICScannerDocumentTypeC1:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC1";
                                break;
                            case ICScannerDocumentTypeC2:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC2";
                                break;
                            case ICScannerDocumentTypeC3:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC3";
                                break;
                            case ICScannerDocumentTypeC7:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC7";
                                break;
                            case ICScannerDocumentTypeC8:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC8";
                                break;
                            case ICScannerDocumentTypeC9:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC9";
                                break;
                            case ICScannerDocumentTypeC10:
                                json_scanner["documentType"] = "ICScannerDocumentTypeC10";
                                break;
                            case ICScannerDocumentTypeUSStatement:
                                json_scanner["documentType"] = "ICScannerDocumentTypeUSStatement";
                                break;
                            case ICScannerDocumentTypeBusinessCard:
                                json_scanner["documentType"] = "ICScannerDocumentTypeBusinessCard";
                                break;
                            case ICScannerDocumentTypeE:
                                json_scanner["documentType"] = "ICScannerDocumentTypeE";
                                break;
                            case ICScannerDocumentType3R:
                                json_scanner["documentType"] = "ICScannerDocumentType3R";
                                break;
                            case ICScannerDocumentType4R:
                                json_scanner["documentType"] = "ICScannerDocumentType4R";
                                break;
                            case ICScannerDocumentType5R:
                                json_scanner["documentType"] = "ICScannerDocumentType5R";
                                break;
                            case ICScannerDocumentType6R:
                                json_scanner["documentType"] = "ICScannerDocumentType6R";
                                break;
                            case ICScannerDocumentType8R:
                                json_scanner["documentType"] = "ICScannerDocumentType8R";
                                break;
                            case ICScannerDocumentTypeS8R:
                                json_scanner["documentType"] = "ICScannerDocumentTypeS8R";
                                break;
                            case ICScannerDocumentType10R:
                                json_scanner["documentType"] = "ICScannerDocumentType10R";
                                break;
                            case ICScannerDocumentTypeS10R:
                                json_scanner["documentType"] = "ICScannerDocumentTypeS10R";
                                break;
                            case ICScannerDocumentType11R:
                                json_scanner["documentType"] = "ICScannerDocumentType11R";
                                break;
                            case ICScannerDocumentType12R:
                                json_scanner["documentType"] = "ICScannerDocumentType12R";
                                break;
                            case ICScannerDocumentTypeS12R:
                                json_scanner["documentType"] = "ICScannerDocumentTypeS12R";
                                break;
                            case ICScannerDocumentType110:
                                json_scanner["documentType"] = "ICScannerDocumentType110";
                                break;
                            case ICScannerDocumentTypeAPSH:
                                json_scanner["documentType"] = "ICScannerDocumentTypeAPSH";
                                break;
                            case ICScannerDocumentTypeAPSC:
                                json_scanner["documentType"] = "ICScannerDocumentTypeAPSC";
                                break;
                            case ICScannerDocumentTypeAPSP:
                                json_scanner["documentType"] = "ICScannerDocumentTypeAPSP";
                                break;
                            case ICScannerDocumentType135:
                                json_scanner["documentType"] = "ICScannerDocumentType135";
                                break;
                            case ICScannerDocumentTypeMF:
                                json_scanner["documentType"] = "ICScannerDocumentTypeMF";
                                break;
                            case ICScannerDocumentTypeLF:
                                json_scanner["documentType"] = "ICScannerDocumentTypeLF";
                                break;
                            default:
                                break;
                        }
                        
                        //NSIndexSet<ICScannerDocumentType>
                        __block Json::Value json_supportedDocumentTypes = Json::Value(Json::arrayValue);
                        
                        NSIndexSet *supportedDocumentTypes = ((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).supportedDocumentTypes;
                        [supportedDocumentTypes enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
                         {
                             switch ((ICScannerDocumentType)idx)
                             {
                                 case ICScannerDocumentTypeDefault:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeDefault");
                                     break;
                                 case ICScannerDocumentTypeA4:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA4");
                                     break;
                                 case ICScannerDocumentTypeB5:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeB5");
                                     break;
                                 case ICScannerDocumentTypeUSLetter:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeUSLetter");
                                     break;
                                 case ICScannerDocumentTypeUSLegal:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeUSLegal");
                                     break;
                                 case ICScannerDocumentTypeA5:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA5");
                                     break;
                                 case ICScannerDocumentTypeISOB4:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB4");
                                     break;
                                 case ICScannerDocumentTypeISOB6:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB6");
                                     break;
                                 case ICScannerDocumentTypeUSLedger:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeUSLedger");
                                     break;
                                 case ICScannerDocumentTypeUSExecutive:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeUSExecutive");
                                     break;
                                 case ICScannerDocumentTypeA3:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA3");
                                     break;
                                 case ICScannerDocumentTypeISOB3:
                                      json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB3");
                                     break;
                                 case ICScannerDocumentTypeA6:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA6");
                                     break;
                                 case ICScannerDocumentTypeC4:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC4");
                                     break;
                                 case ICScannerDocumentTypeC5:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC5");
                                     break;
                                 case ICScannerDocumentTypeC6:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC6");
                                     break;
                                 case ICScannerDocumentType4A0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType4A0");
                                     break;
                                 case ICScannerDocumentType2A0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType2A0");
                                     break;
                                 case ICScannerDocumentTypeA0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA0");
                                     break;
                                 case ICScannerDocumentTypeA1:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA1");
                                     break;
                                 case ICScannerDocumentTypeA2:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA2");
                                     break;
                                 case ICScannerDocumentTypeA7:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA7");
                                     break;
                                 case ICScannerDocumentTypeA8:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA8");
                                     break;
                                 case ICScannerDocumentTypeA9:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeA9");
                                     break;
                                 case ICScannerDocumentType10:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType10");
                                     break;
                                 case ICScannerDocumentTypeISOB0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB0");
                                     break;
                                 case ICScannerDocumentTypeISOB1:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB1");
                                     break;
                                 case ICScannerDocumentTypeISOB2:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB2");
                                     break;
                                 case ICScannerDocumentTypeISOB5:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB5");
                                     break;
                                 case ICScannerDocumentTypeISOB7:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB7");
                                     break;
                                 case ICScannerDocumentTypeISOB8:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB8");
                                     break;
                                 case ICScannerDocumentTypeISOB9:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB9");
                                     break;
                                 case ICScannerDocumentTypeISOB10:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeISOB10");
                                     break;
                                 case ICScannerDocumentTypeJISB0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB0");
                                     break;
                                 case ICScannerDocumentTypeJISB1:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB1");
                                     break;
                                 case ICScannerDocumentTypeJISB2:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB2");
                                     break;
                                 case ICScannerDocumentTypeJISB3:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB3");
                                     break;
                                 case ICScannerDocumentTypeJISB4:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB4");
                                     break;
                                 case ICScannerDocumentTypeJISB6:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB6");
                                     break;
                                 case ICScannerDocumentTypeJISB7:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB7");
                                     break;
                                 case ICScannerDocumentTypeJISB8:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB8");
                                     break;
                                 case ICScannerDocumentTypeJISB9:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB9");
                                     break;
                                 case ICScannerDocumentTypeJISB10:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeJISB10");
                                     break;
                                 case ICScannerDocumentTypeC0:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC0");
                                     break;
                                 case ICScannerDocumentTypeC1:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC1");
                                     break;
                                 case ICScannerDocumentTypeC2:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC2");
                                     break;
                                 case ICScannerDocumentTypeC3:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC3");
                                     break;
                                 case ICScannerDocumentTypeC7:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC7");
                                     break;
                                 case ICScannerDocumentTypeC8:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC8");
                                     break;
                                 case ICScannerDocumentTypeC9:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC9");
                                     break;
                                 case ICScannerDocumentTypeC10:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeC10");
                                     break;
                                 case ICScannerDocumentTypeUSStatement:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeUSStatement");
                                     break;
                                 case ICScannerDocumentTypeBusinessCard:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeBusinessCard");
                                     break;
                                 case ICScannerDocumentTypeE:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeE");
                                     break;
                                 case ICScannerDocumentType3R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType3R");
                                     break;
                                 case ICScannerDocumentType4R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType4R");
                                     break;
                                 case ICScannerDocumentType5R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType5R");
                                     break;
                                 case ICScannerDocumentType6R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType6R");
                                     break;
                                 case ICScannerDocumentType8R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType8R");
                                     break;
                                 case ICScannerDocumentTypeS8R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeS8R");
                                     break;
                                 case ICScannerDocumentType10R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType10R");
                                     break;
                                 case ICScannerDocumentTypeS10R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeS10R");
                                     break;
                                 case ICScannerDocumentType11R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType11R");
                                     break;
                                 case ICScannerDocumentType12R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType12R");
                                     break;
                                 case ICScannerDocumentTypeS12R:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeS12R");
                                     break;
                                 case ICScannerDocumentType110:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType110");
                                     break;
                                 case ICScannerDocumentTypeAPSH:
                                      json_supportedDocumentTypes.append("ICScannerDocumentTypeAPSH");
                                     break;
                                 case ICScannerDocumentTypeAPSC:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeAPSC");
                                     break;
                                 case ICScannerDocumentTypeAPSP:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeAPSP");
                                     break;
                                 case ICScannerDocumentType135:
                                     json_supportedDocumentTypes.append("ICScannerDocumentType135");
                                     break;
                                 case ICScannerDocumentTypeMF:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeMF");
                                     break;
                                 case ICScannerDocumentTypeLF:
                                     json_supportedDocumentTypes.append("ICScannerDocumentTypeLF");
                                     break;
                                 default:
                                     break;
                             }
                         }];
                        
                        json_scanner["supportedDocumentTypes"] = json_supportedDocumentTypes;
                        
                    }
                        break;
                }
                
                switch (currentFunctionalUnit.type) {
                    case ICScannerFunctionalUnitTypeDocumentFeeder:
                    {
                        ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                        //ICScannerFunctionalUnitDocumentFeeder, BOOL
                        
                        json_scanner["duplexScanningEnabled"] = currentFunctionalUnitDocumentFeeder.duplexScanningEnabled;
                        json_scanner["documentLoaded"] = currentFunctionalUnitDocumentFeeder.documentLoaded;
                        json_scanner["reverseFeederPageOrder"] = currentFunctionalUnitDocumentFeeder.reverseFeederPageOrder;
                        json_scanner["supportsDuplexScanning"] = currentFunctionalUnitDocumentFeeder.supportsDuplexScanning;
     
                        //ICScannerFunctionalUnitDocumentFeeder, ICEXIFOrientationType
                        switch (currentFunctionalUnitDocumentFeeder.evenPageOrientation) {
                            case ICEXIFOrientation1:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation1";
                                break;
                            case ICEXIFOrientation2:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation2";
                                break;
                            case ICEXIFOrientation3:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation3";
                                break;
                            case ICEXIFOrientation4:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation4";
                                break;
                            case ICEXIFOrientation5:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation5";
                                break;
                            case ICEXIFOrientation6:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation6";
                                break;
                            case ICEXIFOrientation7:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation7";
                                break;
                            case ICEXIFOrientation8:
                                json_scanner["evenPageOrientation"] = "ICEXIFOrientation8";
                                break;
                            default:
                                break;
                        };
                        switch (currentFunctionalUnitDocumentFeeder.oddPageOrientation) {
                            case ICEXIFOrientation1:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation1";
                                break;
                            case ICEXIFOrientation2:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation2";
                                break;
                            case ICEXIFOrientation3:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation3";
                                break;
                            case ICEXIFOrientation4:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation4";
                                break;
                            case ICEXIFOrientation5:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation5";
                                break;
                            case ICEXIFOrientation6:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation6";
                                break;
                            case ICEXIFOrientation7:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation7";
                                break;
                            case ICEXIFOrientation8:
                                json_scanner["oddPageOrientation"] = "ICEXIFOrientation8";
                                break;
                            default:
                                break;
                        };
                        
                    }
                        break;
                    default:
                        break;
                }
                
            }//currentFunctionalUnit
            
            json_scanners.append(json_scanner);
        }
        
        Json::StreamWriterBuilder builder;
        std::string json = Json::writeString(builder, json_scanners);

        C_TEXT t;
        t.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.size());
        
        CUTF16String u16;
        t.copyUTF16String(&u16);

        devices.setUTF16StringAtIndex(&u16, 0);
    }
    
    void openScanner(C_TEXT &scanner_id, ICScannerFunctionalUnitType scanner_source_type)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            [Scan::device setScanner:scanner];
            
            /*
             Catalina bug:ICScannerFunctionalUnitTypeFlatbed fails
             
             */
            [Scan::device openForSource:scanner_source_type timeout:30];
        }else
        {
            NSLog(@"scanner %@ not found", _scanner_id);
        }
        [_scanner_id release];
    }
    
    void closeScanner(C_TEXT &scanner_id)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            if([scanner hasOpenSession])
            {
                [Scan::device closeWithTimeout:30];
            }else
            {
                NSLog(@"scanner %@ is already closed", _scanner_id);
            }
        }
    }
    
    void runScanner(C_TEXT &scanner_id)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            [Scan::device setScanner:scanner];
            
            if(![scanner hasOpenSession])
            {
                //if the scanner is not open yet, use default (ICScannerFunctionalUnitTypeDocumentFeeder)
                [Scan::device openForSource:ICScannerFunctionalUnitTypeDocumentFeeder timeout:30];
            }
            [Scan::device requestScan];
        }
    }
    
    void cancelScanner(C_TEXT &scanner_id)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            [Scan::device setScanner:scanner];
            
            [Scan::device cancelScan];
        }
    }

    void getOption(C_TEXT &scanner_id, C_LONGINT &option, C_TEXT &result)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            switch(option.getIntValue())
            {
                case 0://Scanner folder path
                {
                    NSURL *downloadsDirectory = [scanner downloadsDirectory];
                    if(downloadsDirectory)
                    {
                        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)downloadsDirectory, kCFURLPOSIXPathStyle);
                        NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path, kCFURLPOSIXPathStyle, TRUE);
                        if(u)
                        {
                            NSString *_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLHFSPathStyle);
                            if(![_path hasSuffix:@":"])
                            {
                                result.setUTF16String([_path stringByAppendingString:@":"]);
                            }else
                            {
                                result.setUTF16String(_path);
                            }
                            [_path release];
                            [u release];
                        }
                        [path release];
                    }
                }
                    break;
                case 1://Scanner document name
                {
                    result.setUTF16String(scanner.documentName);
                }
                    break;
                case 2://Scanner image type
                {
                    result.setUTF16String(scanner.documentUTI);
                }
                    break;
                case 3://Scanner odd page orientation
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            @autoreleasepool
                            {
                                result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnitDocumentFeeder.oddPageOrientation]);
                            }
                        }
                    }
                }
                    break;
                case 4://Scanner even page orientation
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            @autoreleasepool
                            {
                                result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnitDocumentFeeder.evenPageOrientation]);
                            }
                        }
                    }
                }
                    break;
                case 5://Scanner duplex enabled
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            @autoreleasepool
                            {
                                result.setUTF16String([NSString stringWithFormat:@"%i", currentFunctionalUnitDocumentFeeder.duplexScanningEnabled]);
                            }
                        }
                    }
                }
                    break;
                case 6://Scanner document type
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        @autoreleasepool
                        {
                            result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType]);
                        }
                    }
                }
                    break;
                case 7://Scanner scale factor
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        @autoreleasepool
                        {
                            result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.scaleFactor]);
                        }
                    }
                }
                    break;
                case 8://Scanner resolution
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        @autoreleasepool
                        {
                            result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.resolution]);
                        }
                    }
                }
                    break;
                case 9://Scanner bit depth
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        @autoreleasepool
                        {
                            result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.bitDepth]);
                        }
                    }
                }
                    break;
                case 10://Scanner pixel data type
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        @autoreleasepool
                        {
                            result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.pixelDataType]);
                        }
                    }
                }
                    break;
                case 11://Scanner max data size
                {
                    @autoreleasepool
                    {
                        result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)scanner.maxMemoryBandSize]);
                    }
                }
                    break;
                case 12://Scanner transfer mode
                {
                    @autoreleasepool
                    {
                        result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)scanner.transferMode]);
                    }
                }
                    break;
            }
        }
    }
    
    void setOption(C_TEXT &scanner_id, C_LONGINT &option, C_TEXT &value)
    {
        NSString *_scanner_id = scanner_id.copyUTF16String();
        ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
        if(scanner)
        {
            switch(option.getIntValue())
            {
                case 0://Scanner folder path
                {
                    NSURL *downloadsDirectory = value.copyUrl();
                    if(downloadsDirectory)
                    {
                        scanner.downloadsDirectory = downloadsDirectory;
                        [downloadsDirectory release];
                    }
                }
                    break;
                case 1://Scanner document name
                {
                    NSString *documentName = value.copyUTF16String();
                    scanner.documentName = documentName;
                    [documentName release];
                }
                    break;
                case 2://Scanner image type
                {
                    NSString *documentUTI = value.copyUTF16String();
                    if([documentUTI isEqualToString:@"0"]) {scanner.documentUTI = (NSString *)kUTTypeJPEG;}
                    else if([documentUTI isEqualToString:@"1"]) {scanner.documentUTI = (NSString *)kUTTypeTIFF;}
                    else if([documentUTI isEqualToString:@"2"]) {scanner.documentUTI = (NSString *)kUTTypePNG;}
                    else if([documentUTI isEqualToString:@"3"]) {scanner.documentUTI = (NSString *)kUTTypeBMP;}
                    else if([documentUTI isEqualToString:@"4"]) {scanner.documentUTI = (NSString *)kUTTypePDF;}
                    else if([documentUTI isEqualToString:@"5"]) {scanner.documentUTI = (NSString *)kUTTypeGIF;}
                    else if([documentUTI isEqualToString:@"5"]) {scanner.documentUTI = (NSString *)kUTTypeJPEG2000;}
                    [documentUTI release];
                }
                    break;
                case 3://Scanner odd page orientation
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            NSString *oddPageOrientation = value.copyUTF16String();
                            currentFunctionalUnitDocumentFeeder.oddPageOrientation = (ICEXIFOrientationType)[oddPageOrientation integerValue];
                            [oddPageOrientation release];
                        }
                    }
                }
                    break;
                case 4://Scanner even page orientation
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            NSString *evenPageOrientation = value.copyUTF16String();
                            currentFunctionalUnitDocumentFeeder.evenPageOrientation = (ICEXIFOrientationType)[evenPageOrientation integerValue];
                            [evenPageOrientation release];
                        }
                    }
                }
                    break;
                case 5://Scanner duplex enabled
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
                        {
                            ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
                            NSString *duplexScanningEnabled = value.copyUTF16String();
                            currentFunctionalUnitDocumentFeeder.duplexScanningEnabled = (BOOL)[duplexScanningEnabled boolValue];
                            [duplexScanningEnabled release];
                        }
                    }
                }
                    break;
                case 6://Scanner document type
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        NSString *documentType = value.copyUTF16String();
                        ((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType = (ICScannerDocumentType)[documentType integerValue];
                        [documentType release];
                    }
                }
                    break;
                case 7://Scanner scale factor
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        NSString *scaleFactor = value.copyUTF16String();
                        currentFunctionalUnit.scaleFactor = (NSUInteger)[scaleFactor integerValue];
                        [scaleFactor release];
                    }
                }
                    break;
                case 8://Scanner resolution
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        NSString *resolution = value.copyUTF16String();
                        currentFunctionalUnit.resolution = (NSUInteger)[resolution integerValue];
                        [resolution release];
                    }
                }
                    break;
                case 9://Scanner bit depth
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        NSString *bitDepth = value.copyUTF16String();
                        currentFunctionalUnit.bitDepth = (ICScannerBitDepth)[bitDepth integerValue];
                        [bitDepth release];
                    }
                }
                    break;
                case 10://Scanner pixel data type
                {
                    ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
                    if(currentFunctionalUnit)
                    {
                        NSString *pixelDataType = value.copyUTF16String();
                        ICScannerPixelDataType _pixelDataType = (ICScannerPixelDataType)[pixelDataType integerValue];
                        switch (_pixelDataType) {
                            case ICScannerPixelDataTypeBW:
                            case ICScannerPixelDataTypeGray:
                            case ICScannerPixelDataTypeRGB:
                            case ICScannerPixelDataTypePalette:
                            case ICScannerPixelDataTypeCMY:
                            case ICScannerPixelDataTypeCMYK:
                            case ICScannerPixelDataTypeYUV:
                            case ICScannerPixelDataTypeYUVK:
                            case ICScannerPixelDataTypeCIEXYZ:
                                currentFunctionalUnit.pixelDataType = _pixelDataType;
                                break;
                            default:
                                break;
                        }
                        [pixelDataType release];
                    }
                }
                    break;
                case 11://Scanner max data size
                {
                    NSString *maxMemoryBandSize = value.copyUTF16String();
                    scanner.maxMemoryBandSize = (UInt32)[maxMemoryBandSize integerValue];
                    [maxMemoryBandSize release];
                }
                    break;
                case 12://Scanner transfer mode
                {
                    NSString *transferMode = value.copyUTF16String();
                    scanner.transferMode = (ICScannerTransferMode)[transferMode integerValue];
                    [transferMode release];
                }
                    break;
            }//switch
        }
    }
}

#pragma mark -

#pragma mark Listener

void listenerLoopExecuteMethod() {
    
    std::vector<param_scan_type_t>::iterator oldest_param_scan_type;
    std::vector<param_scan_path_t>::iterator oldest_param_scan_path;
    std::vector<param_scan_data_t>::iterator oldest_param_scan_data;
    std::vector<param_scan_info_t>::iterator oldest_param_scan_info;
    
    param_scan_type_t param_scan_type;
    param_scan_path_t param_scan_path;
    param_scan_data_t param_scan_data;
    param_scan_info_t param_scan_info;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);

        oldest_param_scan_type = Scan::CALLBACK_PARAMS_SCAN_TYPE.begin();
        param_scan_type = *oldest_param_scan_type;
        
        oldest_param_scan_path = Scan::CALLBACK_PARAMS_SCAN_PATH.begin();
        param_scan_path = *oldest_param_scan_path;
        
        oldest_param_scan_data = Scan::CALLBACK_PARAMS_SCAN_DATA.begin();
        param_scan_data = *oldest_param_scan_data;

        oldest_param_scan_info = Scan::CALLBACK_PARAMS_SCAN_INFO.begin();
        param_scan_info = *oldest_param_scan_info;
    }
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Scan::LISTENER_METHOD.getUTF16StringPtr());
    
    /*
     
     signature of callback method:
     
     $1 <C_LONGINT>:param_scan_type
     $2 <C_TEXT>:param_scan_path
     $3 <C_BLOB>:param_scan_data
     $4 <C_TEXT>:param_scan_context_info
     
     */
    
    if(methodId)
    {
        PA_Variable    params[5];
        params[0] = PA_CreateVariable(eVK_Longint);
        params[1] = PA_CreateVariable(eVK_Unistring);
        params[2] = PA_CreateVariable(eVK_Blob);
        params[3] = PA_CreateVariable(eVK_Unistring);
        params[4] = PA_CreateVariable(eVK_Unistring);
        
        PA_SetLongintVariable(&params[0], param_scan_type);
        PA_Unistring path = PA_CreateUnistring((PA_Unichar *)param_scan_path.c_str());
        PA_SetStringVariable(&params[1], &path);
        PA_SetBlobVariable(&params[2], (void *)&param_scan_data[0], (PA_long32)param_scan_data.size());
        PA_Unistring ctx = PA_CreateUnistring((PA_Unichar *)Scan::CALLBACK_METHOD_CONTEXT_INFO.c_str());
        PA_SetStringVariable(&params[3], &ctx);
        PA_Unistring info = PA_CreateUnistring((PA_Unichar *)param_scan_info.c_str());
        PA_SetStringVariable(&params[4], &info);
        
        PA_ExecuteMethodByID(methodId, params, 5);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        PA_ClearVariable(&params[3]);
        PA_ClearVariable(&params[4]);
    }else{
        
        PA_Variable    params[6];
        params[1] = PA_CreateVariable(eVK_Longint);
        params[2] = PA_CreateVariable(eVK_Unistring);
        params[3] = PA_CreateVariable(eVK_Blob);
        params[4] = PA_CreateVariable(eVK_Unistring);
        params[5] = PA_CreateVariable(eVK_Unistring);
        
        PA_SetLongintVariable(&params[1], param_scan_type);
        PA_Unistring path = PA_CreateUnistring((PA_Unichar *)param_scan_path.c_str());
        PA_SetStringVariable(&params[2], &path);
        PA_SetBlobVariable(&params[3], (void *)&param_scan_data[0], (PA_long32)param_scan_data.size());
        PA_Unistring ctx = PA_CreateUnistring((PA_Unichar *)Scan::CALLBACK_METHOD_CONTEXT_INFO.c_str());
        PA_SetStringVariable(&params[4], &ctx);
        PA_Unistring info = PA_CreateUnistring((PA_Unichar *)param_scan_info.c_str());
        PA_SetStringVariable(&params[5], &info);
        
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)Scan::LISTENER_METHOD.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &method);
        
        /* execute method */
        PA_ExecuteCommandByID(1007, params, 6);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        PA_ClearVariable(&params[3]);
        PA_ClearVariable(&params[4]);
        PA_ClearVariable(&params[5]);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
     
        Scan::CALLBACK_PARAMS_SCAN_TYPE.erase(oldest_param_scan_type);
        Scan::CALLBACK_PARAMS_SCAN_PATH.erase(oldest_param_scan_path);
        Scan::CALLBACK_PARAMS_SCAN_DATA.erase(oldest_param_scan_data);
        Scan::CALLBACK_PARAMS_SCAN_INFO.erase(oldest_param_scan_info);
    }
}

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        Scan::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!/*Scan::MONITOR_PROCESS_SHOULD_TERMINATE*/PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = Scan::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = Scan::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
             size_t SCANS;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                SCANS = Scan::CALLBACK_PARAMS_SCAN_TYPE.size();
            }
            
            while(SCANS)
            {
                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                                Scan::MONITOR_PROCESS_STACK_SIZE,
                                                (PA_Unichar *)processName.getUTF16StringPtr());
                }else
                {
                    listenerLoopExecuteMethod();
                }
                                
                if (PROCESS_SHOULD_TERMINATE)
                break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    SCANS = Scan::CALLBACK_PARAMS_SCAN_TYPE.size();
                    PROCESS_SHOULD_TERMINATE = Scan::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                Scan::PROCESS_SHOULD_RESUME = false;
            }

        }else
        {
            /* DELAY PROCESS does not work for PA_NewProcess */
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = Scan::PROCESS_SHOULD_TERMINATE;
        }
        
        if (PROCESS_SHOULD_TERMINATE)
        break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        Scan::CALLBACK_PARAMS_SCAN_PATH.clear();
        Scan::CALLBACK_PARAMS_SCAN_TYPE.clear();
        Scan::CALLBACK_PARAMS_SCAN_DATA.clear();
        Scan::CALLBACK_PARAMS_SCAN_INFO.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        Scan::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        Scan::MONITOR_PROCESS_ID = 0;
    }
    
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!Scan::MONITOR_PROCESS_ID)
    {
        Scan::MONITOR_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                                                         Scan::MONITOR_PROCESS_STACK_SIZE,
                                                                                         Scan::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
    if(Scan::MONITOR_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            Scan::PROCESS_SHOULD_TERMINATE = true;
        }
                
        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            Scan::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        Scan::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        Scan::PROCESS_SHOULD_RESUME = true;
    }

}

#pragma mark -

@implementation Scanner

- (id)init
{
    if(!(self = [super init])) return self;
    
    _waiting = NO;
    _error = 0;
    _scanner = nil;
    
    return self;
}

- (void)dealloc
{
    if(_scanner)
    {
        _scanner.delegate = nil;
        _scanner = nil;
    }
    
    [super dealloc];
}

- (void)setScanner:(ICScannerDevice *)scanner
{
    _waiting = NO;
    _error = 0;
    _scanner = scanner;
    _scanner.delegate = self;
}

- (id)initWithScanner:(ICScannerDevice *)scanner
{
    if(!(self = [super init])) return self;
    
    [self setScanner:scanner];
    
    return self;
}

- (BOOL)openForSource:(ICScannerFunctionalUnitType)source timeout:(NSUInteger)seconds
{
    if(![_scanner hasOpenSession])
    {
        @autoreleasepool
        {
            NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
            NSTimeInterval end = now + seconds;
            NSUInteger count = end - now;
            
            _waiting = YES;
            
            [_scanner requestOpenSession];
            
            do {
                
                PA_YieldAbsolute();
                
                now = [NSDate timeIntervalSinceReferenceDate];
                if(count != (NSUInteger)(end - now))
                {
                    count = end - now;
                    NSLog(@"%@ will run for %i more seconds",@"requestOpenSession", (int)count);
                }
                
            } while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
            
            if(_waiting)
            {
                NSLog(@"%@ did not complete in %i seconds",@"requestOpenSession", (int)seconds);
                _waiting = NO;
            }
            
            NSLog(@"end of %@", @"requestOpenSession");
            
        }//@autoreleasepool
    }else
    {
        NSLog(@"scanner is already open, skip %@", @"requestOpenSession");
    }
    
    if([_scanner hasOpenSession])
    {
        @autoreleasepool
        {
            NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
            NSTimeInterval end = now + seconds;
            NSUInteger count = end - now;
            
            _waiting = YES;
            
            [_scanner requestSelectFunctionalUnit:source];
            do {
                
                PA_YieldAbsolute();
                
                now = [NSDate timeIntervalSinceReferenceDate];
                if(count != (NSUInteger)(end - now))
                {
                    count = end - now;
                    NSLog(@"%@ will run for %i more seconds",@"requestSelectFunctionalUnit", (int)count);
                }
                
            } while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
            
            if(_waiting)
            {
                NSLog(@"%@ did not complete in %i seconds",@"requestSelectFunctionalUnit", (int)seconds);
                _waiting = NO;
            }
            
            NSLog(@"end of %@", @"requestSelectFunctionalUnit");
            
        }//@autoreleasepool
    }else
    {
        NSLog(@"scanner is not open, skip %@", @"requestSelectFunctionalUnit");
    }
    
    return [_scanner hasOpenSession] && [_scanner selectedFunctionalUnit];
}

- (BOOL)closeWithTimeout:(NSUInteger)seconds
{
    if([_scanner hasOpenSession])
    {
        @autoreleasepool
        {
            NSTimeInterval end = [NSDate timeIntervalSinceReferenceDate] + seconds;
            _waiting = YES;
            [_scanner requestCloseSession];
            do {
                PA_YieldAbsolute();
            } while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
            if(_waiting)
            {
                NSLog(@"%@ did not complete in %i seconds",@"requestCloseSession", (int)seconds);
            }
            _waiting = NO;
        }
    }
    
    return ![_scanner hasOpenSession];
}

- (void)requestScan
{
    [_scanner requestScan];
}

- (void)cancelScan
{
    [_scanner cancelScan];
}

- (void)breakWithOutError
{
    _waiting = NO;
}

- (void)breakWithError:(NSError *)error
{
    _error = error ? [error code] : 0;
    _waiting = NO;
}

#pragma mark ICDeviceDelegate

- (void)didRemoveDevice:(ICDevice *)device
{
    [device requestCloseSession];
    
    [self breakWithOutError];
}

- (void)device:(ICDevice *)device didOpenSessionWithError:(NSError *)error
{
    [self breakWithError:error];
}

- (void)deviceDidBecomeReady:(ICDevice *)device
{
    [self breakWithOutError];
}

- (void)device:(ICDevice *)device didCloseSessionWithError:(NSError *)error
{
    [self breakWithError:error];
}

- (void)deviceDidChangeName:(ICDevice *)device
{
    //not implemented
}

- (void)deviceDidChangeSharingState:(ICDevice *)device
{
    //not implemented
}

- (void)device:(ICDevice *)device didReceiveStatusInformation:(NSDictionary *)status
{
    //not implemented
}

- (void)device:(ICDevice *)device didEncounterError:(NSError *)error
{
    
    if (1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        param_scan_type_t result = param_scan_type_error;
        param_scan_path_t param_scan_path;/* no path */
        param_scan_data_t param_scan_data;/* no data */
        
        param_scan_info_t param_scan_info;
        C_TEXT t;
        t.setUTF16String([error description]);
        t.copyUTF16String(&param_scan_info);
        
        Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(result);
        Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
        Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
        Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(param_scan_info);

    }
    
    [self breakWithError:error];
}

- (void)device:(ICDevice *)device didReceiveButtonPress:(NSString *)buttonType
{
    //not implemented
}

- (void)device:(ICDevice *)device didReceiveCustomNotification:(NSDictionary *)notification data:(NSData *)data
{
    //not implemented
}

#pragma mark -

#pragma mark Event

- (void)didCompleteScanWithError:(NSError *)error
{
    _error = error ? [error code] : 0;
    
    
    
    listenerLoopExecute();
}

- (void)didScanToBandData:(ICScannerBandData *)data
{

    if (1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        param_scan_path_t param_scan_path;
        param_scan_data_t param_scan_data;
        param_scan_info_t param_scan_info;
        
        NSData *buf = [data dataBuffer];
        param_scan_data.resize([buf length]);
        [buf getBytes:&param_scan_data[0] length:param_scan_data.size()];
        
        Json::Value json_info;

        json_info["dataSize"] = (unsigned int)[data dataSize];
        json_info["dataNumRows"] = (unsigned int)[data dataNumRows];
        json_info["dataStartRow"] = (unsigned int)[data dataStartRow];
        json_info["bytesPerRow"] = (unsigned int)[data bytesPerRow];
        json_info["numComponents"] = (unsigned int)[data numComponents];
        json_info["bitsPerComponent"] = (unsigned int)[data bitsPerComponent];
        json_info["bitsPerPixel"] = (unsigned int)[data bitsPerPixel];
        json_info["fullImageHeight"] = (unsigned int)[data fullImageHeight];
        json_info["fullImageWidth"] = (unsigned int)[data fullImageWidth];
        
        json_info["isBigEndian"] = [data isBigEndian];
        
        switch ([data pixelDataType]) {
            case ICScannerPixelDataTypeBW:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeBW";
                break;
            case ICScannerPixelDataTypeGray:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeGray";
                break;
            case ICScannerPixelDataTypeRGB:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeRGB";
                break;
            case ICScannerPixelDataTypePalette:
                json_info["pixelDataType"] = "ICScannerPixelDataTypePalette";
                break;
            case ICScannerPixelDataTypeCMY:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeCMY";
                break;
            case ICScannerPixelDataTypeCMYK:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeCMYK";
                break;
            case ICScannerPixelDataTypeYUV:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeYUV";
                break;
            case ICScannerPixelDataTypeYUVK:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeYUVK";
                break;
            case ICScannerPixelDataTypeCIEXYZ:
                json_info["pixelDataType"] = "ICScannerPixelDataTypeCIEXYZ";
                break;
            default:
                break;
        };
        
        json_info["colorSyncProfilePath"] = [[data colorSyncProfilePath]UTF8String];
        
        Json::StreamWriterBuilder builder;
        std::string json = Json::writeString(builder, json_info);
        
        C_TEXT t;
        t.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.size());
        
        CUTF16String u16;
        t.copyUTF16String(&u16);
        
        Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(param_scan_type_data);
        Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
        Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
        Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(u16);

    }
    
    listenerLoopExecute();
}

- (void)didScanToURL:(NSURL *)url
{

    if (1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        param_scan_path_t param_scan_path;
        param_scan_data_t param_scan_data;
        param_scan_info_t param_scan_info;
        
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
        uint32_t len = (uint32_t)[path length];
        uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
        std::vector<uint8_t> buf(size);
        if([path getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
        {
            param_scan_path = CUTF16String((const PA_Unichar *)&buf[0], len);
        }
        [path release];
        
        Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(param_scan_type_file);
        Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
        Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
        Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(param_scan_info);

    }
    
    listenerLoopExecute();
}

#pragma mark -

#pragma mark ICScannerDeviceDelegate

- (void)scannerDeviceDidBecomeAvailable:(ICScannerDevice *)scanner
{
    //not implemented
}

- (void)scannerDevice:(ICScannerDevice *)scanner didScanToURL:(NSURL *)url
{
    [self didScanToURL:url];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didScanToBandData:(ICScannerBandData *)data
{
    [self didScanToBandData:data];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didSelectFunctionalUnit:(ICScannerFunctionalUnit *)functionalUnit error:(NSError *)error
{
    [self breakWithError:error];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didCompleteOverviewScanWithError:(NSError *)error
{
    [self breakWithError:error];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didCompleteScanWithError:(NSError *)error;
{
    [self didCompleteScanWithError:error];
}

@end

@implementation ScannerBrowser

- (id)init
{
    if(!(self = [super init])) return self;
    
    _scanners = [[NSMutableArray alloc]initWithCapacity:0];
    
    return self;
}

- (void)dealloc
{
    [_scanners release];
    
    [super dealloc];
}

- (ICScannerDevice *)scannerForIdentifier:(NSString *)uuid
{
    ICScannerDevice *scanner = nil;
    if(uuid)
    {
        NSUInteger i = [_scanners indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
                                        {
                                            if ([[(ICDevice*)obj UUIDString] isEqualToString:uuid])
                                            {
                                                return YES;
                                            }
                                            return NO;
                                        }];
        
        if(NSNotFound != i)
        {
            scanner = [_scanners objectAtIndex:i];
        };
    }
    return scanner;
}

@synthesize scanners = _scanners;

#pragma mark ICDeviceBrowserDelegate

- (void)deviceBrowser:(ICDeviceBrowser *)browser didAddDevice:(ICDevice *)addedDevice moreComing:(BOOL)moreComing
{
    if([addedDevice isKindOfClass:[ICScannerDevice class]])
    {
        [_scanners addObject:addedDevice];
    }
}

- (void)deviceBrowser:(ICDeviceBrowser *)browser didRemoveDevice:(ICDevice *)device moreGoing:(BOOL)moreGoing
{
    
    NSUInteger i = [_scanners indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
                                    {
                                        if ([[(ICDevice*)obj UUIDString] isEqualToString:[device UUIDString]])
                                        {
                                            return YES;
                                        }
                                        return NO;
                                    }];
    
    if(NSNotFound != i)
    {
        [_scanners removeObjectAtIndex:i];
    };
}

@end

bool IsProcessOnExit()
{
    PA_long32 state, time;
    
    std::vector<PA_Unichar>buf(33);
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), &buf[0], &state, &time);
    CUTF16String procName(&buf[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

void OnStartup()
{
#if VERSIONMAC
    Scan::startDeviceBrowser();
    listenerLoopStart();
#endif
}

void OnExit()
{
#if VERSIONMAC
    Scan::cleanupWithTimeout(10);
    Scan::stopDeviceBrowser();
    listenerLoopFinish();
#endif
}

void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        OnExit();
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
                case kInitPlugin :
                case kServerInitPlugin :
                    OnStartup();
                    break;
                    
                case kCloseProcess :
                    OnCloseProcess();
                    break;
                
			// --- ImageCaptureCore
            
			case 1 :
				ICA_SCANNERS_LIST(params);
				break;
			case 2 :
				ICA_SET_SCAN_OPTION(params);
				break;
			case 3 :
				ICA_OPEN_SCANNER_SESSION(params);
				break;
			case 4 :
				ICA_CLOSE_SCANNER_SESSION(params);
				break;
			case 5 :
				ICA_SCAN(params);
				break;
			case 6 :
				ICA_CANCEL(params);
				break;
			case 7 :
				ICA_Get_scan_option(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void ICA_SCANNERS_LIST(PA_PluginParameters params) {

    //    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1_scanners_list;
    
    Scan::getScanners(Param1_scanners_list);
    
    Param1_scanners_list.toParamAtIndex(pParams, 1);
}

void ICA_SET_SCAN_OPTION(PA_PluginParameters params) {
 
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    C_LONGINT Param2_option;
    C_TEXT Param3_value;
    
    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    Param2_option.fromParamAtIndex(pParams, 2);
    Param3_value.fromParamAtIndex(pParams, 3);
    
    Scan::setOption(Param1_scanner_id, Param2_option, Param3_value);
}

void ICA_OPEN_SCANNER_SESSION(PA_PluginParameters params) {

    //    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    C_LONGINT Param2_source;
    
    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    Param2_source.fromParamAtIndex(pParams, 2);
    
    ICScannerFunctionalUnitType scanner_source_type = (ICScannerFunctionalUnitType)Param2_source.getIntValue();
    
    Scan::openScanner(Param1_scanner_id, scanner_source_type);
}

void ICA_CLOSE_SCANNER_SESSION(PA_PluginParameters params) {

    //    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    
    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    
    Scan::closeScanner(Param1_scanner_id);
}

void ICA_SCAN(PA_PluginParameters params) {

    //    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    C_TEXT Param3_user_info;

    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    Param3_user_info.fromParamAtIndex(pParams, 3);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        Scan::LISTENER_METHOD.fromParamAtIndex(pParams, 2);
    }
    
    Scan::setMethod(Param3_user_info);
    
    Scan::runScanner(Param1_scanner_id);
}

void ICA_CANCEL(PA_PluginParameters params) {

//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    
    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    
    Scan::runScanner(Param1_scanner_id);
}

void ICA_Get_scan_option(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner_id;
    C_LONGINT Param2_option;
    C_TEXT returnValue;

    Param1_scanner_id.fromParamAtIndex(pParams, 1);
    Param2_option.fromParamAtIndex(pParams, 2);

    Scan::getOption(Param1_scanner_id, Param2_option, returnValue);

    returnValue.setReturn(pResult);
}
