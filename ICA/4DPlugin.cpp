/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ImageCaptureCore
 #	author : miyako
 #	2017/09/07
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark Utility

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

#if VERSIONMAC
#pragma mark Browser
namespace Scan
{
	//globals
	ICDeviceBrowser *deviceBrowser = nil;
	ScannerBrowser *deviceBrowserDelegate = nil;
	Scanner *device = nil;
	
	param_scan_context_info_t CALLBACK_METHOD_CONTEXT_INFO;
	process_number_t MONITOR_PROCESS_ID = 0;
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
	method_id_t CALLBACK_METHOD_ID = 0;
	bool MONITOR_PROCESS_SHOULD_TERMINATE = false;
	
	//constant
	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0S\0C\0A\0N\0N\0E\0R\0\0\0";

	//callback params
	std::vector<param_scan_path_t>CALLBACK_PARAMS_SCAN_PATH;
	std::vector<param_scan_type_t>CALLBACK_PARAMS_SCAN_TYPE;
	std::vector<param_scan_data_t>CALLBACK_PARAMS_SCAN_DATA;
	std::vector<param_scan_info_t>CALLBACK_PARAMS_SCAN_INFO;
	
	void startDeviceBrowser()
	{
		Scan::deviceBrowserDelegate = [[ScannerBrowser alloc]init];
		Scan::deviceBrowser = [[ICDeviceBrowser alloc]init];
		Scan::deviceBrowser.delegate = Scan::deviceBrowserDelegate;
		Scan::deviceBrowser.browsedDeviceTypeMask = ICDeviceAnyScanner;
		[Scan::deviceBrowser start];
		
		Scan::device = [[Scanner alloc]init];
	}
	
	void stopDeviceBrowser()
	{
		
		//!important:not the time to dispatch new objc messages
		//	[Scan::deviceBrowser stop];
		
		Scan::deviceBrowser.delegate = nil;
		[Scan::deviceBrowser release];
		
		[Scan::deviceBrowserDelegate release];
		[Scan::device release];
	}
	
#pragma mark -
	
#pragma mark API
	
	void setMethod(C_TEXT &method, C_TEXT &context_info)
	{
		CALLBACK_METHOD_CONTEXT_INFO = CUTF16String(context_info.getUTF16StringPtr(), context_info.getUTF16Length());
		
		if(!method.getUTF16Length())
		{
			CALLBACK_METHOD_ID = 0;
		}else
		{
			method_id_t methodId = PA_GetMethodID((PA_Unichar *)method.getUTF16StringPtr());
			if((methodId) && (methodId != CALLBACK_METHOD_ID))
			{
				CALLBACK_METHOD_ID = methodId;
				NSLog(@"callback method set: %i", (int)methodId);
			}
		}
	}
	
	void cleanupWithTimeout(NSUInteger seconds)
	{
		NSArray *scanners = [deviceBrowserDelegate scanners];
		for(NSUInteger i = 0;i < [scanners count];++i)
		{
			ICScannerDevice *scanner = (ICScannerDevice *)[scanners objectAtIndex:i];
			if([scanner hasOpenSession])
			{
				@autoreleasepool
				{
					NSTimeInterval end = [NSDate timeIntervalSinceReferenceDate] + seconds;
					[scanner requestCloseSession];
					do {
						PA_YieldAbsolute();
					} while ([scanner hasOpenSession] && ([NSDate timeIntervalSinceReferenceDate] < end));
				}
			}//
		}//scanners
	}
	
	void getScanners(ARRAY_TEXT &devices)
	{
		NSArray *scanners = [deviceBrowserDelegate scanners];
		
		devices.setSize(1);
		JSONNODE *json_scanners = json_new(JSON_ARRAY);
		
		for(NSUInteger i = 0;i < [scanners count];++i)
		{
			ICScannerDevice *scanner = (ICScannerDevice *)[scanners objectAtIndex:i];
			devices.appendUTF16String([scanner UUIDString]);
			
			JSONNODE *json_scanner = json_new(JSON_NODE);
			
			//ICDevice, NSString
			json_set_text(json_scanner, L"name", [scanner name]);
			json_set_path(json_scanner, L"modulePath", [scanner modulePath]);
			json_set_path(json_scanner, L"iconPath", [scanner performSelector:@selector(iconPath)]);
			
			json_set_text(json_scanner, L"moduleVersion", [[scanner moduleVersion]
																										 stringByReplacingOccurrencesOfString:@"\n"
																										 withString:@""]);//contains LF (hp Officejet Pro 8600)
			
			json_set_text(json_scanner, L"autolaunchApplicationPath", [scanner autolaunchApplicationPath]);
			json_set_text(json_scanner, L"persistentIDString", [scanner persistentIDString]);
			json_set_text(json_scanner, L"UUIDString", [scanner UUIDString]);
			json_set_text(json_scanner, L"locationDescription", [scanner locationDescription]);
			json_set_text(json_scanner, L"serialNumberString", [scanner serialNumberString]);
			json_set_text(json_scanner, L"transportType", [scanner transportType]);
			
			//ICDevice, hidden
			//https://github.com/pombredanne/osx_headers/blob/master/Frameworks/ImageCaptureCore/ICDevice.h
			json_set_text(json_scanner, L"ipAddress", [scanner performSelector:@selector(ipAddress)]);
			
			//ICDevice, BOOL
			json_set_bool(json_scanner, L"isRemote", [scanner isRemote]);
			json_set_bool(json_scanner, L"isShared", [scanner isShared]);
			json_set_bool(json_scanner, L"hasConfigurableWiFiInterface", [scanner hasConfigurableWiFiInterface]);
			json_set_bool(json_scanner, L"hasOpenSession", [scanner hasOpenSession]);
			
			//ICDevice, int
			json_set_i(json_scanner, L"usbVendorID", [scanner usbVendorID]);
			json_set_i(json_scanner, L"usbProductID", [scanner usbProductID]);
			json_set_i(json_scanner, L"usbLocationID", [scanner usbLocationID]);
			
			json_set_i(json_scanner, L"moduleExecutableArchitecture", [scanner moduleExecutableArchitecture]);
			
			//ICScannerDevice, NSString
			json_set_text(json_scanner, L"documentName", [scanner documentName]);
			json_set_text(json_scanner, L"documentUTI", [scanner documentUTI]);
			
			//convert to hfs path
			NSURL *downloadsDirectory = [scanner downloadsDirectory];
			if(downloadsDirectory)
			{
				NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)downloadsDirectory, kCFURLPOSIXPathStyle);
				json_set_path(json_scanner, L"downloadsDirectory", path, TRUE);
				[path release];
			}else
			{
				json_set_null(json_scanner, L"downloadsDirectory");
			}
	
			switch ([scanner transferMode]) {
				case ICScannerTransferModeFileBased:
					json_set_text(json_scanner, L"transferMode", @"ICScannerTransferModeFileBased");
					break;
				case ICScannerTransferModeMemoryBased:
					json_set_text(json_scanner, L"transferMode", @"ICScannerTransferModeFileBased");
					break;
				default:
					break;
			};
			
			//ICScannerDevice, UInt32
			json_set_i(json_scanner, L"maxMemoryBandSize", [scanner maxMemoryBandSize]);
			
			//ICScannerFunctionalUnit
			ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
			
			//session needs to be open
			if(currentFunctionalUnit)
			{
				//ICScannerFunctionalUnit, NSIndexSet<ICScannerBitDepth>
				JSONNODE *json_supportedBitDepths = json_new(JSON_ARRAY);
				NSIndexSet *supportedBitDepths = currentFunctionalUnit.supportedBitDepths;
				[supportedBitDepths enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_supportedBitDepth = json_new(JSON_STRING);
					 switch ((ICScannerBitDepth)idx)
					 {
						 case ICScannerBitDepth1Bit:
							 json_set_a(json_supportedBitDepth, L"ICScannerBitDepth1Bit");
							 json_push_back(json_supportedBitDepths, json_supportedBitDepth);
							 break;
						 case ICScannerBitDepth8Bits:
							 json_set_a(json_supportedBitDepth, L"ICScannerBitDepth8Bits");
							 json_push_back(json_supportedBitDepths, json_supportedBitDepth);
							 break;
						 case ICScannerBitDepth16Bits:
							 json_set_a(json_supportedBitDepth, L"ICScannerBitDepth16Bits");
							 json_push_back(json_supportedBitDepths, json_supportedBitDepth);
							 break;
						 default:
							 json_delete(json_supportedBitDepth);
							 break;
					 }
				 }];
				json_set_name(json_supportedBitDepths, L"supportedBitDepths");
				json_push_back(json_scanner, json_supportedBitDepths);
				
				//ICScannerFunctionalUnit, NSIndexSet<ICScannerMeasurementUnit>
				JSONNODE *json_supportedMeasurementUnits = json_new(JSON_ARRAY);
				NSIndexSet *supportedMeasurementUnits = currentFunctionalUnit.supportedMeasurementUnits;
				[supportedMeasurementUnits enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_supportedMeasurementUnit = json_new(JSON_STRING);
					 switch ((ICScannerMeasurementUnit)idx)
					 {
						 case ICScannerMeasurementUnitInches:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitInches");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 case ICScannerMeasurementUnitCentimeters:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitCentimeters");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 case ICScannerMeasurementUnitPicas:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitPicas");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 case ICScannerMeasurementUnitPoints:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitPoints");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 case ICScannerMeasurementUnitTwips:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitTwips");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 case ICScannerMeasurementUnitPixels:
							 json_set_a(json_supportedMeasurementUnit, L"ICScannerMeasurementUnitPixels");
							 json_push_back(json_supportedMeasurementUnits, json_supportedMeasurementUnit);
							 break;
						 default:
							 json_delete(json_supportedMeasurementUnit);
							 break;
					 }
				 }];
				json_set_name(json_supportedMeasurementUnits, L"supportedMeasurementUnits");
				json_push_back(json_scanner, json_supportedMeasurementUnits);
				
				//ICScannerFunctionalUnit, NSIndexSet<NSUInteger>
				JSONNODE *json_preferredResolutions = json_new(JSON_ARRAY);
				NSIndexSet *preferredResolutions = currentFunctionalUnit.preferredResolutions;
				[preferredResolutions enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_preferredResolution = json_new(JSON_NUMBER);
					 json_set_i(json_preferredResolution, idx);
					 json_push_back(json_preferredResolutions, json_preferredResolution);
				 }];
				json_set_name(json_preferredResolutions, L"preferredResolutions");
				json_push_back(json_scanner, json_preferredResolutions);
				
				JSONNODE *json_supportedResolutions = json_new(JSON_ARRAY);
				NSIndexSet *supportedResolutions = currentFunctionalUnit.supportedResolutions;
				[supportedResolutions enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_supportedResolution = json_new(JSON_NUMBER);
					 json_set_i(json_supportedResolution, idx);
					 json_push_back(json_supportedResolutions, json_supportedResolution);
				 }];
				json_set_name(json_supportedResolutions, L"supportedResolutions");
				json_push_back(json_scanner, json_supportedResolutions);
				
				JSONNODE *json_preferredScaleFactors = json_new(JSON_ARRAY);
				NSIndexSet *preferredScaleFactors = currentFunctionalUnit.preferredScaleFactors;
				[preferredScaleFactors enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_preferredScaleFactor = json_new(JSON_NUMBER);
					 json_set_i(json_preferredScaleFactor, idx);
					 json_push_back(json_preferredScaleFactors, json_preferredScaleFactor);
				 }];
				json_set_name(json_preferredScaleFactors, L"preferredScaleFactors");
				json_push_back(json_scanner, json_preferredScaleFactors);
				
				JSONNODE *json_supportedScaleFactors = json_new(JSON_ARRAY);
				NSIndexSet *supportedScaleFactors = currentFunctionalUnit.supportedScaleFactors;
				[supportedScaleFactors enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
				 {
					 JSONNODE *json_supportedScaleFactor = json_new(JSON_NUMBER);
					 json_set_i(json_supportedScaleFactor, idx);
					 json_push_back(json_supportedScaleFactors, json_supportedScaleFactor);
				 }];
				json_set_name(json_supportedScaleFactors, L"supportedScaleFactors");
				json_push_back(json_scanner, json_supportedScaleFactors);
				
				//ICScannerFunctionalUnit, ICScannerMeasurementUnit
				switch (currentFunctionalUnit.measurementUnit) {
					case ICScannerMeasurementUnitInches:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitInches");
						break;
					case ICScannerMeasurementUnitCentimeters:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitCentimeters");
						break;
					case ICScannerMeasurementUnitPicas:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitPicas");
						break;
					case ICScannerMeasurementUnitPoints:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitPoints");
						break;
					case ICScannerMeasurementUnitTwips:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitTwips");
						break;
					case ICScannerMeasurementUnitPixels:
						json_set_text(json_scanner, L"measurementUnit", @"ICScannerMeasurementUnitPixels");
						break;
					default:
						break;
				};
				
				//ICScannerFunctionalUnit, ICScannerPixelDataType
				switch (currentFunctionalUnit.pixelDataType) {
					case ICScannerPixelDataTypeBW:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeBW");
						break;
					case ICScannerPixelDataTypeGray:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeGray");
						break;
					case ICScannerPixelDataTypeRGB:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeRGB");
						break;
					case ICScannerPixelDataTypePalette:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypePalette");
						break;
					case ICScannerPixelDataTypeCMY:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeCMY");
						break;
					case ICScannerPixelDataTypeCMYK:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeCMYK");
						break;
					case ICScannerPixelDataTypeYUV:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeYUV");
						break;
					case ICScannerPixelDataTypeYUVK:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeYUVK");
						break;
					case ICScannerPixelDataTypeCIEXYZ:
						json_set_text(json_scanner, L"pixelDataType", @"ICScannerPixelDataTypeCIEXYZ");
						break;
					default:
						break;
				};
				
				//ICScannerFunctionalUnit, ICScannerBitDepth
				switch (currentFunctionalUnit.bitDepth) {
					case ICScannerBitDepth1Bit:
						json_set_text(json_scanner, L"bitDepth", @"ICScannerBitDepth1Bit");
						break;
					case ICScannerBitDepth8Bits:
						json_set_text(json_scanner, L"bitDepth", @"ICScannerBitDepth8Bits");
						break;
					case ICScannerBitDepth16Bits:
						json_set_text(json_scanner, L"bitDepth", @"ICScannerBitDepth16Bits");
						break;
					default:
						break;
				};
				
				//ICScannerFunctionalUnit, NSSize
				NSSize physicalSize = currentFunctionalUnit.physicalSize;
				JSONNODE *json_physicalSize = json_new(JSON_NODE);
				json_set_f(json_physicalSize, L"width", physicalSize.width);
				json_set_f(json_physicalSize, L"height", physicalSize.height);
				json_set_name(json_physicalSize, L"physicalSize");
				json_push_back(json_scanner, json_physicalSize);
				
				//ICScannerFunctionalUnit, NSRect
				NSRect scanArea = currentFunctionalUnit.scanArea;
				JSONNODE *json_scanArea = json_new(JSON_NODE);
				json_set_f(json_scanArea, L"x", scanArea.origin.x);
				json_set_f(json_scanArea, L"y", scanArea.origin.y);
				json_set_f(json_scanArea, L"width", scanArea.size.width);
				json_set_f(json_scanArea, L"height", scanArea.size.height);
				json_set_name(json_scanArea, L"scanArea");
				json_push_back(json_scanner, json_scanArea);
				
				//ICScannerFunctionalUnit, CGFloat
				json_set_i(json_scanner, L"scanProgressPercentDone", currentFunctionalUnit.scanProgressPercentDone);
				
				//ICScannerFunctionalUnit, NSUInteger
				json_set_i(json_scanner, L"resolution", currentFunctionalUnit.resolution);
				json_set_i(json_scanner, L"nativeXResolution", currentFunctionalUnit.nativeXResolution);
				json_set_i(json_scanner, L"nativeYResolution", currentFunctionalUnit.nativeYResolution);
				json_set_i(json_scanner, L"overviewResolution", currentFunctionalUnit.overviewResolution);
				json_set_i(json_scanner, L"scaleFactor", currentFunctionalUnit.scaleFactor);
				
				//ICScannerFunctionalUnit, unsigned char
				json_set_i(json_scanner, L"thresholdForBlackAndWhiteScanning", currentFunctionalUnit.thresholdForBlackAndWhiteScanning);
				json_set_i(json_scanner, L"defaultThresholdForBlackAndWhiteScanning", currentFunctionalUnit.defaultThresholdForBlackAndWhiteScanning);
				
				//ICScannerFunctionalUnit, BOOL
				json_set_bool(json_scanner, L"overviewScanInProgress", currentFunctionalUnit.overviewScanInProgress);
				json_set_bool(json_scanner, L"canPerformOverviewScan", currentFunctionalUnit.canPerformOverviewScan);
				json_set_bool(json_scanner, L"scanInProgress", currentFunctionalUnit.scanInProgress);
				json_set_bool(json_scanner, L"acceptsThresholdForBlackAndWhiteScanning", currentFunctionalUnit.acceptsThresholdForBlackAndWhiteScanning);
				json_set_bool(json_scanner, L"usesThresholdForBlackAndWhiteScanning", currentFunctionalUnit.usesThresholdForBlackAndWhiteScanning);
				
				switch (currentFunctionalUnit.type) {
					case ICScannerFunctionalUnitTypeFlatbed:
					case ICScannerFunctionalUnitTypeDocumentFeeder:
					case ICScannerFunctionalUnitTypeNegativeTransparency:
					case ICScannerFunctionalUnitTypePositiveTransparency:
					{
						/*
						 all document types
						 @property supportedDocumentTypes
						 @property documentType
						 @property documentSize
						 */
						
						//NSSize
						NSSize documentSize = ((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentSize;
						JSONNODE *json_documentSize = json_new(JSON_NODE);
						json_set_f(json_documentSize, L"width", documentSize.width);
						json_set_f(json_documentSize, L"height", documentSize.height);
						json_set_name(json_documentSize, L"documentSize");
						json_push_back(json_scanner, json_documentSize);
						
						//ICScannerDocumentType
						switch (((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType) {
							case ICScannerDocumentTypeDefault:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeDefault");
								break;
							case ICScannerDocumentTypeA4:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA4");
								break;
							case ICScannerDocumentTypeB5:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeB5");
								break;
							case ICScannerDocumentTypeUSLetter:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeUSLetter");
								break;
							case ICScannerDocumentTypeUSLegal:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeUSLegal");
								break;
							case ICScannerDocumentTypeA5:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA5");
								break;
							case ICScannerDocumentTypeISOB4:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB4");
								break;
							case ICScannerDocumentTypeISOB6:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB6");
								break;
							case ICScannerDocumentTypeUSLedger:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeUSLedger");
								break;
							case ICScannerDocumentTypeUSExecutive:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeUSExecutive");
								break;
							case ICScannerDocumentTypeA3:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA3");
								break;
							case ICScannerDocumentTypeISOB3:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB3");
								break;
							case ICScannerDocumentTypeA6:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA6");
								break;
							case ICScannerDocumentTypeC4:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC4");
								break;
							case ICScannerDocumentTypeC5:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC5");
								break;
							case ICScannerDocumentTypeC6:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC6");
								break;
							case ICScannerDocumentType4A0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType4A0");
								break;
							case ICScannerDocumentType2A0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType2A0");
								break;
							case ICScannerDocumentTypeA0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA0");
								break;
							case ICScannerDocumentTypeA1:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA1");
								break;
							case ICScannerDocumentTypeA2:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA2");
								break;
							case ICScannerDocumentTypeA7:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA7");
								break;
							case ICScannerDocumentTypeA8:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA8");
								break;
							case ICScannerDocumentTypeA9:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeA9");
								break;
							case ICScannerDocumentType10:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType10");
								break;
							case ICScannerDocumentTypeISOB0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB0");
								break;
							case ICScannerDocumentTypeISOB1:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB1");
								break;
							case ICScannerDocumentTypeISOB2:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB2");
								break;
							case ICScannerDocumentTypeISOB5:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB5");
								break;
							case ICScannerDocumentTypeISOB7:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB7");
								break;
							case ICScannerDocumentTypeISOB8:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB8");
								break;
							case ICScannerDocumentTypeISOB9:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB9");
								break;
							case ICScannerDocumentTypeISOB10:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeISOB10");
								break;
							case ICScannerDocumentTypeJISB0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB0");
								break;
							case ICScannerDocumentTypeJISB1:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB1");
								break;
							case ICScannerDocumentTypeJISB2:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB2");
								break;
							case ICScannerDocumentTypeJISB3:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB3");
								break;
							case ICScannerDocumentTypeJISB4:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB4");
								break;
							case ICScannerDocumentTypeJISB6:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB6");
								break;
							case ICScannerDocumentTypeJISB7:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB7");
								break;
							case ICScannerDocumentTypeJISB8:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB8");
								break;
							case ICScannerDocumentTypeJISB9:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB9");
								break;
							case ICScannerDocumentTypeJISB10:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeJISB10");
								break;
							case ICScannerDocumentTypeC0:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC0");
								break;
							case ICScannerDocumentTypeC1:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC1");
								break;
							case ICScannerDocumentTypeC2:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC2");
								break;
							case ICScannerDocumentTypeC3:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC3");
								break;
							case ICScannerDocumentTypeC7:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC7");
								break;
							case ICScannerDocumentTypeC8:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC8");
								break;
							case ICScannerDocumentTypeC9:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC9");
								break;
							case ICScannerDocumentTypeC10:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeC10");
								break;
							case ICScannerDocumentTypeUSStatement:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeUSStatement");
								break;
							case ICScannerDocumentTypeBusinessCard:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeBusinessCard");
								break;
							case ICScannerDocumentTypeE:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeE");
								break;
							case ICScannerDocumentType3R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType3R");
								break;
							case ICScannerDocumentType4R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType4R");
								break;
							case ICScannerDocumentType5R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType5R");
								break;
							case ICScannerDocumentType6R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType6R");
								break;
							case ICScannerDocumentType8R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType8R");
								break;
							case ICScannerDocumentTypeS8R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeS8R");
								break;
							case ICScannerDocumentType10R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType10R");
								break;
							case ICScannerDocumentTypeS10R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeS10R");
								break;
							case ICScannerDocumentType11R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType11R");
								break;
							case ICScannerDocumentType12R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType12R");
								break;
							case ICScannerDocumentTypeS12R:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeS12R");
								break;
							case ICScannerDocumentType110:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType110");
								break;
							case ICScannerDocumentTypeAPSH:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeAPSH");
								break;
							case ICScannerDocumentTypeAPSC:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeAPSC");
								break;
							case ICScannerDocumentTypeAPSP:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeAPSP");
								break;
							case ICScannerDocumentType135:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentType135");
								break;
							case ICScannerDocumentTypeMF:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeMF");
								break;
							case ICScannerDocumentTypeLF:
								json_set_text(json_scanner, L"documentType", @"ICScannerDocumentTypeLF");
								break;
							default:
								break;
						}
						
						//NSIndexSet<ICScannerDocumentType>
						JSONNODE *json_supportedDocumentTypes = json_new(JSON_ARRAY);
						NSIndexSet *supportedDocumentTypes = ((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).supportedDocumentTypes;
						[supportedDocumentTypes enumerateIndexesUsingBlock:^void(NSUInteger idx, BOOL *stop)
						 {
							 JSONNODE *json_supportedDocumentType = json_new(JSON_STRING);
							 switch ((ICScannerDocumentType)idx)
							 {
								 case ICScannerDocumentTypeDefault:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeDefault");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA4:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA4");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeB5:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeB5");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeUSLetter:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeUSLetter");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeUSLegal:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeUSLegal");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA5:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA5");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB4:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB4");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB6:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB6");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeUSLedger:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeUSLedger");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeUSExecutive:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeUSExecutive");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA3:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA3");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB3:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB3");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA6:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA6");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC4:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC4");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC5:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC5");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC6:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC6");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType4A0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType4A0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType2A0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType2A0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA1:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA1");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA2:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA2");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA7:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA7");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA8:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA8");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeA9:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeA9");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType10:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType10");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB1:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB1");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB2:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB2");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB5:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB5");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB7:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB7");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB8:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB8");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB9:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB9");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeISOB10:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeISOB10");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB1:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB1");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB2:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB2");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB3:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB3");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB4:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB4");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB6:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB6");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB7:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB7");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB8:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB8");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB9:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB9");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeJISB10:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeJISB10");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC0:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC0");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC1:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC1");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC2:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC2");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC3:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC3");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC7:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC7");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC8:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC8");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC9:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC9");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeC10:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeC10");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeUSStatement:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeUSStatement");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeBusinessCard:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeBusinessCard");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeE:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeE");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType3R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType3R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType4R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType4R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType5R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType5R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType6R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType6R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType8R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType8R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeS8R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeS8R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType10R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType10R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeS10R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeS10R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType11R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType11R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType12R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType12R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeS12R:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeS12R");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType110:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType110");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeAPSH:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeAPSH");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeAPSC:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeAPSC");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeAPSP:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeAPSP");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentType135:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentType135");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeMF:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeMF");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 case ICScannerDocumentTypeLF:
									 json_set_a(json_supportedDocumentType, L"ICScannerDocumentTypeLF");
									 json_push_back(json_supportedDocumentTypes, json_supportedDocumentType);
									 break;
								 default:
									 json_delete(json_supportedDocumentType);
									 break;
							 }
						 }];
						json_set_name(json_supportedDocumentTypes, L"supportedDocumentTypes");
						json_push_back(json_scanner, json_supportedDocumentTypes);
						
					}
						break;
				}
				
				switch (currentFunctionalUnit.type) {
					case ICScannerFunctionalUnitTypeDocumentFeeder:
					{
						ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
						//ICScannerFunctionalUnitDocumentFeeder, BOOL
						json_set_bool(json_scanner, L"duplexScanningEnabled", currentFunctionalUnitDocumentFeeder.duplexScanningEnabled);
						json_set_bool(json_scanner, L"documentLoaded", currentFunctionalUnitDocumentFeeder.documentLoaded);
						json_set_bool(json_scanner, L"reverseFeederPageOrder", currentFunctionalUnitDocumentFeeder.reverseFeederPageOrder);
						json_set_bool(json_scanner, L"supportsDuplexScanning", currentFunctionalUnitDocumentFeeder.supportsDuplexScanning);
						
						//ICScannerFunctionalUnitDocumentFeeder, ICEXIFOrientationType
						switch (currentFunctionalUnitDocumentFeeder.evenPageOrientation) {
							case ICEXIFOrientation1:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation1");
								break;
							case ICEXIFOrientation2:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation2");
								break;
							case ICEXIFOrientation3:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation3");
								break;
							case ICEXIFOrientation4:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation4");
								break;
							case ICEXIFOrientation5:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation5");
								break;
							case ICEXIFOrientation6:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation6");
								break;
							case ICEXIFOrientation7:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation7");
								break;
							case ICEXIFOrientation8:
								json_set_text(json_scanner, L"evenPageOrientation", @"ICEXIFOrientation8");
								break;
							default:
								break;
						};
						switch (currentFunctionalUnitDocumentFeeder.oddPageOrientation) {
							case ICEXIFOrientation1:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation1");
								break;
							case ICEXIFOrientation2:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation2");
								break;
							case ICEXIFOrientation3:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation3");
								break;
							case ICEXIFOrientation4:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation4");
								break;
							case ICEXIFOrientation5:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation5");
								break;
							case ICEXIFOrientation6:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation6");
								break;
							case ICEXIFOrientation7:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation7");
								break;
							case ICEXIFOrientation8:
								json_set_text(json_scanner, L"oddPageOrientation", @"ICEXIFOrientation8");
								break;
							default:
								break;
						};
						
					}
						break;
					default:
						break;
				}
				
			}//currentFunctionalUnit
			
			
			json_push_back(json_scanners, json_scanner);
		}
		
		CUTF16String json;
		json_stringify(json_scanners, json);
		json_delete(json_scanners);
		devices.setUTF16StringAtIndex(&json, 0);
	}
	
	void openScanner(C_TEXT &scanner_id, ICScannerFunctionalUnitType scanner_source_type)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			[Scan::device setScanner:scanner];
			[Scan::device openForSource:scanner_source_type timeout:30];
		}else
		{
			NSLog(@"scanner %@ not found", _scanner_id);
		}
		[_scanner_id release];
	}
	
	void closeScanner(C_TEXT &scanner_id)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			if([scanner hasOpenSession])
			{
				[Scan::device closeWithTimeout:30];
			}else
			{
				NSLog(@"scanner %@ is already closed", _scanner_id);
			}
		}
	}
	
	void runScanner(C_TEXT &scanner_id)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			[Scan::device setScanner:scanner];
			
			if(![scanner hasOpenSession])
			{
				//if the scanner is not open yet, use default (ICScannerFunctionalUnitTypeDocumentFeeder)
				[Scan::device openForSource:ICScannerFunctionalUnitTypeDocumentFeeder timeout:30];
			}
			[Scan::device requestScan];
		}
	}
	
	void cancelScanner(C_TEXT &scanner_id)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			[Scan::device setScanner:scanner];
			
			[Scan::device cancelScan];
		}
	}

	void getOption(C_TEXT &scanner_id, C_LONGINT &option, C_TEXT &result)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			switch(option.getIntValue())
			{
				case 0://Scanner folder path
				{
					NSURL *downloadsDirectory = [scanner downloadsDirectory];
					if(downloadsDirectory)
					{
						NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)downloadsDirectory, kCFURLPOSIXPathStyle);
						NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path, kCFURLPOSIXPathStyle, TRUE);
						if(u)
						{
							NSString *_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLHFSPathStyle);
							if(![_path hasSuffix:@":"])
							{
								result.setUTF16String([_path stringByAppendingString:@":"]);
							}else
							{
								result.setUTF16String(_path);
							}
							[_path release];
							[u release];
						}
						[path release];
					}
				}
					break;
				case 1://Scanner document name
				{
					result.setUTF16String(scanner.documentName);
				}
					break;
				case 2://Scanner image type
				{
					result.setUTF16String(scanner.documentUTI);
				}
					break;
				case 3://Scanner odd page orientation
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							@autoreleasepool
							{
								result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnitDocumentFeeder.oddPageOrientation]);
							}
						}
					}
				}
					break;
				case 4://Scanner even page orientation
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							@autoreleasepool
							{
								result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnitDocumentFeeder.evenPageOrientation]);
							}
						}
					}
				}
					break;
				case 5://Scanner duplex enabled
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							@autoreleasepool
							{
								result.setUTF16String([NSString stringWithFormat:@"%i", currentFunctionalUnitDocumentFeeder.duplexScanningEnabled]);
							}
						}
					}
				}
					break;
				case 6://Scanner document type
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						@autoreleasepool
						{
							result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType]);
						}
					}
				}
					break;
				case 7://Scanner scale factor
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						@autoreleasepool
						{
							result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.scaleFactor]);
						}
					}
				}
					break;
				case 8://Scanner resolution
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						@autoreleasepool
						{
							result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.resolution]);
						}
					}
				}
					break;
				case 9://Scanner bit depth
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						@autoreleasepool
						{
							result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.bitDepth]);
						}
					}
				}
					break;
				case 10://Scanner pixel data type
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						@autoreleasepool
						{
							result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)currentFunctionalUnit.pixelDataType]);
						}
					}
				}
					break;
				case 11://Scanner max data size
				{
					@autoreleasepool
					{
						result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)scanner.maxMemoryBandSize]);
					}
				}
					break;
				case 12://Scanner transfer mode
				{
					@autoreleasepool
					{
						result.setUTF16String([NSString stringWithFormat:@"%i", (unsigned int)scanner.transferMode]);
					}
				}
					break;
			}
		}
	}
	
	void setOption(C_TEXT &scanner_id, C_LONGINT &option, C_TEXT &value)
	{
		NSString *_scanner_id = scanner_id.copyUTF16String();
		ICScannerDevice *scanner = [deviceBrowserDelegate scannerForIdentifier:_scanner_id];
		if(scanner)
		{
			switch(option.getIntValue())
			{
				case 0://Scanner folder path
				{
					NSURL *downloadsDirectory = value.copyUrl();
					if(downloadsDirectory)
					{
						scanner.downloadsDirectory = downloadsDirectory;
						[downloadsDirectory release];
					}
				}
					break;
				case 1://Scanner document name
				{
					NSString *documentName = value.copyUTF16String();
					scanner.documentName = documentName;
					[documentName release];
				}
					break;
				case 2://Scanner image type
				{
					NSString *documentUTI = value.copyUTF16String();
					if([documentUTI isEqualToString:@"0"]) {scanner.documentUTI = (NSString *)kUTTypeJPEG;}
					else if([documentUTI isEqualToString:@"1"]) {scanner.documentUTI = (NSString *)kUTTypeTIFF;}
					else if([documentUTI isEqualToString:@"2"]) {scanner.documentUTI = (NSString *)kUTTypePNG;}
					else if([documentUTI isEqualToString:@"3"]) {scanner.documentUTI = (NSString *)kUTTypeBMP;}
					else if([documentUTI isEqualToString:@"4"]) {scanner.documentUTI = (NSString *)kUTTypePDF;}
					else if([documentUTI isEqualToString:@"5"]) {scanner.documentUTI = (NSString *)kUTTypeGIF;}
					else if([documentUTI isEqualToString:@"5"]) {scanner.documentUTI = (NSString *)kUTTypeJPEG2000;}
					[documentUTI release];
				}
					break;
				case 3://Scanner odd page orientation
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							NSString *oddPageOrientation = value.copyUTF16String();
							currentFunctionalUnitDocumentFeeder.oddPageOrientation = (ICEXIFOrientationType)[oddPageOrientation integerValue];
							[oddPageOrientation release];
						}
					}
				}
					break;
				case 4://Scanner even page orientation
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							NSString *evenPageOrientation = value.copyUTF16String();
							currentFunctionalUnitDocumentFeeder.evenPageOrientation = (ICEXIFOrientationType)[evenPageOrientation integerValue];
							[evenPageOrientation release];
						}
					}
				}
					break;
				case 5://Scanner duplex enabled
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						if(currentFunctionalUnit.type == ICScannerFunctionalUnitTypeDocumentFeeder)
						{
							ICScannerFunctionalUnitDocumentFeeder *currentFunctionalUnitDocumentFeeder = (ICScannerFunctionalUnitDocumentFeeder *)currentFunctionalUnit;
							NSString *duplexScanningEnabled = value.copyUTF16String();
							currentFunctionalUnitDocumentFeeder.duplexScanningEnabled = (BOOL)[duplexScanningEnabled boolValue];
							[duplexScanningEnabled release];
						}
					}
				}
					break;
				case 6://Scanner document type
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						NSString *documentType = value.copyUTF16String();
						((ICScannerFunctionalUnitFlatbed *)currentFunctionalUnit).documentType = (ICScannerDocumentType)[documentType integerValue];
						[documentType release];
					}
				}
					break;
				case 7://Scanner scale factor
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						NSString *scaleFactor = value.copyUTF16String();
						currentFunctionalUnit.scaleFactor = (NSUInteger)[scaleFactor integerValue];
						[scaleFactor release];
					}
				}
					break;
				case 8://Scanner resolution
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						NSString *resolution = value.copyUTF16String();
						currentFunctionalUnit.resolution = (NSUInteger)[resolution integerValue];
						[resolution release];
					}
				}
					break;
				case 9://Scanner bit depth
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						NSString *bitDepth = value.copyUTF16String();
						currentFunctionalUnit.bitDepth = (ICScannerBitDepth)[bitDepth integerValue];
						[bitDepth release];
					}
				}
					break;
				case 10://Scanner pixel data type
				{
					ICScannerFunctionalUnit *currentFunctionalUnit = [scanner selectedFunctionalUnit];
					if(currentFunctionalUnit)
					{
						NSString *pixelDataType = value.copyUTF16String();
						ICScannerPixelDataType _pixelDataType = (ICScannerPixelDataType)[pixelDataType integerValue];
						switch (_pixelDataType) {
							case ICScannerPixelDataTypeBW:
							case ICScannerPixelDataTypeGray:
							case ICScannerPixelDataTypeRGB:
							case ICScannerPixelDataTypePalette:
							case ICScannerPixelDataTypeCMY:
							case ICScannerPixelDataTypeCMYK:
							case ICScannerPixelDataTypeYUV:
							case ICScannerPixelDataTypeYUVK:
							case ICScannerPixelDataTypeCIEXYZ:
								currentFunctionalUnit.pixelDataType = _pixelDataType;
								break;
							default:
								break;
						}
						[pixelDataType release];
					}
				}
					break;
				case 11://Scanner max data size
				{
					NSString *maxMemoryBandSize = value.copyUTF16String();
					scanner.maxMemoryBandSize = (UInt32)[maxMemoryBandSize integerValue];
					[maxMemoryBandSize release];
				}
					break;
				case 12://Scanner transfer mode
				{
					NSString *transferMode = value.copyUTF16String();
					scanner.transferMode = (ICScannerTransferMode)[transferMode integerValue];
					[transferMode release];
				}
					break;
			}//switch
		}
	}
}

#pragma mark -

#pragma mark Listener

void listenerExecuteMethod()
{
	std::vector<param_scan_type_t>::iterator oldest_param_scan_type = Scan::CALLBACK_PARAMS_SCAN_TYPE.begin();
	param_scan_type_t param_scan_type = *oldest_param_scan_type;
	
	std::vector<param_scan_path_t>::iterator oldest_param_scan_path = Scan::CALLBACK_PARAMS_SCAN_PATH.begin();
	param_scan_path_t param_scan_path = *oldest_param_scan_path;
	
	std::vector<param_scan_data_t>::iterator oldest_param_scan_data = Scan::CALLBACK_PARAMS_SCAN_DATA.begin();
	param_scan_data_t param_scan_data = *oldest_param_scan_data;

	std::vector<param_scan_info_t>::iterator oldest_param_scan_info = Scan::CALLBACK_PARAMS_SCAN_INFO.begin();
	param_scan_info_t param_scan_info = *oldest_param_scan_info;
	
	PA_Variable	params[5];
	/*
	 
	 signature of callback method:
	 
	 $1 <C_LONGINT>:param_scan_type
	 $2 <C_TEXT>:param_scan_path
	 $3 <C_BLOB>:param_scan_data
	 $4 <C_TEXT>:param_scan_context_info
	 
	 */
	
	params[0] = PA_CreateVariable(eVK_Longint);
	params[1] = PA_CreateVariable(eVK_Unistring);
	params[2] = PA_CreateVariable(eVK_Blob);
	params[3] = PA_CreateVariable(eVK_Unistring);
	params[4] = PA_CreateVariable(eVK_Unistring);
	
	PA_SetLongintVariable(&params[0], param_scan_type);
	PA_Unistring path = PA_CreateUnistring((PA_Unichar *)param_scan_path.c_str());
	PA_SetStringVariable(&params[1], &path);
	PA_SetBlobVariable(&params[2], (void *)&param_scan_data[0], (PA_long32)param_scan_data.size());
	PA_Unistring ctx = PA_CreateUnistring((PA_Unichar *)Scan::CALLBACK_METHOD_CONTEXT_INFO.c_str());
	PA_SetStringVariable(&params[3], &ctx);
	PA_Unistring info = PA_CreateUnistring((PA_Unichar *)param_scan_info.c_str());
	PA_SetStringVariable(&params[4], &info);
	
	Scan::CALLBACK_PARAMS_SCAN_TYPE.erase(oldest_param_scan_type);
	Scan::CALLBACK_PARAMS_SCAN_PATH.erase(oldest_param_scan_path);
	Scan::CALLBACK_PARAMS_SCAN_DATA.erase(oldest_param_scan_data);
	Scan::CALLBACK_PARAMS_SCAN_INFO.erase(oldest_param_scan_info);
	
	if(Scan::CALLBACK_METHOD_ID)
	{
		PA_ExecuteMethodByID(Scan::CALLBACK_METHOD_ID, params, 5);
	}
	
	PA_ClearVariable(&params[0]);
	PA_ClearVariable(&params[1]);
	PA_ClearVariable(&params[2]);
	PA_ClearVariable(&params[3]);
	PA_ClearVariable(&params[4]);
}

void listenerLoop()
{
	Scan::MONITOR_PROCESS_SHOULD_TERMINATE = false;
	
	while(!Scan::MONITOR_PROCESS_SHOULD_TERMINATE)
	{
		PA_YieldAbsolute();
		
		while(Scan::CALLBACK_PARAMS_SCAN_TYPE.size())
		{
			C_TEXT processName;
			generateUuid(processName);
			PA_NewProcess((void *)listenerExecuteMethod,
										Scan::MONITOR_PROCESS_STACK_SIZE,
										(PA_Unichar *)processName.getUTF16StringPtr());
			
			if(Scan::MONITOR_PROCESS_SHOULD_TERMINATE)
				break;
		}
		
		if(!Scan::MONITOR_PROCESS_SHOULD_TERMINATE)
		{
			PA_FreezeProcess(PA_GetCurrentProcessNumber());
		}else{
			Scan::MONITOR_PROCESS_ID = 0;
		}
	}
	PA_KillProcess();
}

void listenerLoopStart()
{
	if(!Scan::MONITOR_PROCESS_ID)
	{
		Scan::MONITOR_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
																						 Scan::MONITOR_PROCESS_STACK_SIZE,
																						 Scan::MONITOR_PROCESS_NAME);
	}
}

void listenerLoopFinish()
{
	
	if(Scan::MONITOR_PROCESS_ID)
	{
		Scan::MONITOR_PROCESS_SHOULD_TERMINATE = true;
		
		PA_YieldAbsolute();
		
		Scan::CALLBACK_METHOD_ID = 0;
		Scan::CALLBACK_PARAMS_SCAN_PATH.clear();
		Scan::CALLBACK_PARAMS_SCAN_TYPE.clear();
		Scan::CALLBACK_PARAMS_SCAN_DATA.clear();
		Scan::CALLBACK_PARAMS_SCAN_INFO.clear();
		
		PA_UnfreezeProcess(Scan::MONITOR_PROCESS_ID);
	}
}

void listenerLoopExecute()
{
	Scan::MONITOR_PROCESS_SHOULD_TERMINATE = false;
	PA_UnfreezeProcess(Scan::MONITOR_PROCESS_ID);
}

#pragma mark -

@implementation Scanner

- (id)init
{
	if(!(self = [super init])) return self;
	
	_waiting = NO;
	_error = 0;
	_scanner = nil;
	
	return self;
}

- (void)dealloc
{
	if(_scanner)
	{
		_scanner.delegate = nil;
		_scanner = nil;
	}
	
	[super dealloc];
}

- (void)setScanner:(ICScannerDevice *)scanner
{
	_waiting = NO;
	_error = 0;
	_scanner = scanner;
	_scanner.delegate = self;
}

- (id)initWithScanner:(ICScannerDevice *)scanner
{
	if(!(self = [super init])) return self;
	
	[self setScanner:scanner];
	
	return self;
}

- (BOOL)openForSource:(ICScannerFunctionalUnitType)source timeout:(NSUInteger)seconds
{
	if(![_scanner hasOpenSession])
	{
		@autoreleasepool
		{
			NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
			NSTimeInterval end = now + seconds;
			NSUInteger count = end - now;
			
			_waiting = YES;
			
			[_scanner requestOpenSession];
			
			do {
				
				PA_YieldAbsolute();
				
				now = [NSDate timeIntervalSinceReferenceDate];
				if(count != (NSUInteger)(end - now))
				{
					count = end - now;
					NSLog(@"%@ will run for %i more seconds",@"requestOpenSession", (int)count);
				}
				
			} while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
			
			if(_waiting)
			{
				NSLog(@"%@ did not complete in %i seconds",@"requestOpenSession", (int)seconds);
				_waiting = NO;
			}
			
			NSLog(@"end of %@", @"requestOpenSession");
			
		}//@autoreleasepool
	}else
	{
		NSLog(@"scanner is already open, skip %@", @"requestOpenSession");
	}
	
	if([_scanner hasOpenSession])
	{
		@autoreleasepool
		{
			NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
			NSTimeInterval end = now + seconds;
			NSUInteger count = end - now;
			
			_waiting = YES;
			
			[_scanner requestSelectFunctionalUnit:source];
			do {
				
				PA_YieldAbsolute();
				
				now = [NSDate timeIntervalSinceReferenceDate];
				if(count != (NSUInteger)(end - now))
				{
					count = end - now;
					NSLog(@"%@ will run for %i more seconds",@"requestSelectFunctionalUnit", (int)count);
				}
				
			} while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
			
			if(_waiting)
			{
				NSLog(@"%@ did not complete in %i seconds",@"requestSelectFunctionalUnit", (int)seconds);
				_waiting = NO;
			}
			
			NSLog(@"end of %@", @"requestSelectFunctionalUnit");
			
		}//@autoreleasepool
	}else
	{
		NSLog(@"scanner is not open, skip %@", @"requestSelectFunctionalUnit");
	}
	
	return [_scanner hasOpenSession] && [_scanner selectedFunctionalUnit];
}

- (BOOL)closeWithTimeout:(NSUInteger)seconds
{
	if([_scanner hasOpenSession])
	{
		@autoreleasepool
		{
			NSTimeInterval end = [NSDate timeIntervalSinceReferenceDate] + seconds;
			_waiting = YES;
			[_scanner requestCloseSession];
			do {
				PA_YieldAbsolute();
			} while (_waiting && ([NSDate timeIntervalSinceReferenceDate] < end));
			if(_waiting)
			{
				NSLog(@"%@ did not complete in %i seconds",@"requestCloseSession", (int)seconds);
			}
			_waiting = NO;
		}
	}
	
	return ![_scanner hasOpenSession];
}

- (void)requestScan
{
	[_scanner requestScan];
}

- (void)cancelScan
{
	[_scanner cancelScan];
}

- (void)breakWithOutError
{
	_waiting = NO;
}

- (void)breakWithError:(NSError *)error
{
	_error = error ? [error code] : 0;
	_waiting = NO;
}

#pragma mark ICDeviceDelegate

- (void)didRemoveDevice:(ICDevice *)device
{
	[device requestCloseSession];
	
	[self breakWithOutError];
}

- (void)device:(ICDevice *)device didOpenSessionWithError:(NSError *)error
{
	[self breakWithError:error];
}

- (void)deviceDidBecomeReady:(ICDevice *)device
{
	[self breakWithOutError];
}

- (void)device:(ICDevice *)device didCloseSessionWithError:(NSError *)error
{
	[self breakWithError:error];
}

- (void)deviceDidChangeName:(ICDevice *)device
{
	//not implemented
}

- (void)deviceDidChangeSharingState:(ICDevice *)device
{
	//not implemented
}

- (void)device:(ICDevice *)device didReceiveStatusInformation:(NSDictionary *)status
{
	//not implemented
}

- (void)device:(ICDevice *)device didEncounterError:(NSError *)error
{
	[self breakWithError:error];
}

- (void)device:(ICDevice *)device didReceiveButtonPress:(NSString *)buttonType
{
	//not implemented
}

- (void)device:(ICDevice *)device didReceiveCustomNotification:(NSDictionary *)notification data:(NSData *)data
{
	//not implemented
}

#pragma mark -

#pragma mark Event

- (void)didCompleteScanWithError:(NSError *)error
{
	_error = error ? [error code] : 0;
	
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		param_scan_type_t result = _error ? param_scan_type_error : param_scan_type_success;
		param_scan_path_t param_scan_path;
		param_scan_data_t param_scan_data;
		param_scan_info_t param_scan_info;
		
		Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(result);
		Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
		Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
		Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(param_scan_info);
		
		[l unlock];
	}
	[l release];
	
	listenerLoopExecute();
}

- (void)didScanToBandData:(ICScannerBandData *)data
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		param_scan_path_t param_scan_path;
		param_scan_data_t param_scan_data;
		param_scan_info_t param_scan_info;
		
		NSData *buf = [data dataBuffer];
		param_scan_data.resize([buf length]);
		[buf getBytes:&param_scan_data[0] length:param_scan_data.size()];
		
		JSONNODE *json_info = json_new(JSON_NODE);
		json_set_i(json_info, L"dataSize", [data dataSize]);
		json_set_i(json_info, L"dataNumRows", [data dataNumRows]);
		json_set_i(json_info, L"dataStartRow", [data dataStartRow]);
		json_set_i(json_info, L"bytesPerRow", [data bytesPerRow]);
		json_set_i(json_info, L"numComponents", [data numComponents]);
		json_set_i(json_info, L"bitsPerComponent", [data bitsPerComponent]);
		json_set_i(json_info, L"bitsPerPixel", [data bitsPerPixel]);
		json_set_i(json_info, L"fullImageHeight", [data fullImageHeight]);
		json_set_i(json_info, L"fullImageWidth", [data fullImageWidth]);

		json_set_bool(json_info, L"isBigEndian", [data isBigEndian]);
		
		switch ([data pixelDataType]) {
			case ICScannerPixelDataTypeBW:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeBW");
				break;
			case ICScannerPixelDataTypeGray:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeGray");
				break;
			case ICScannerPixelDataTypeRGB:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeRGB");
				break;
			case ICScannerPixelDataTypePalette:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypePalette");
				break;
			case ICScannerPixelDataTypeCMY:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeCMY");
				break;
			case ICScannerPixelDataTypeCMYK:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeCMYK");
				break;
			case ICScannerPixelDataTypeYUV:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeYUV");
				break;
			case ICScannerPixelDataTypeYUVK:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeYUVK");
				break;
			case ICScannerPixelDataTypeCIEXYZ:
				json_set_text(json_info, L"pixelDataType", @"ICScannerPixelDataTypeCIEXYZ");
				break;
			default:
				break;
		};
		
		json_set_text(json_info, L"colorSyncProfilePath", [data colorSyncProfilePath]);
		
		json_stringify(json_info, param_scan_info);
		json_delete(json_info);
		
		Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(param_scan_type_data);
		Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
		Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
		Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(param_scan_info);
		
		[l unlock];
	}
	[l release];
	
	listenerLoopExecute();
}

- (void)didScanToURL:(NSURL *)url
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		param_scan_path_t param_scan_path;
		param_scan_data_t param_scan_data;
		param_scan_info_t param_scan_info;
		
		NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
		uint32_t len = (uint32_t)[path length];
		uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		if([path getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
		{
			param_scan_path = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
		[path release];
		
		Scan::CALLBACK_PARAMS_SCAN_TYPE.push_back(param_scan_type_file);
		Scan::CALLBACK_PARAMS_SCAN_PATH.push_back(param_scan_path);
		Scan::CALLBACK_PARAMS_SCAN_DATA.push_back(param_scan_data);
		Scan::CALLBACK_PARAMS_SCAN_INFO.push_back(param_scan_info);
		
		[l unlock];
	}
	[l release];
	
	listenerLoopExecute();
}

#pragma mark -

#pragma mark ICScannerDeviceDelegate

- (void)scannerDeviceDidBecomeAvailable:(ICScannerDevice *)scanner
{
	//not implemented
}

- (void)scannerDevice:(ICScannerDevice *)scanner didScanToURL:(NSURL *)url
{
	[self didScanToURL:url];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didScanToBandData:(ICScannerBandData *)data
{
	[self didScanToBandData:data];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didSelectFunctionalUnit:(ICScannerFunctionalUnit *)functionalUnit error:(NSError *)error
{
	[self breakWithError:error];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didCompleteOverviewScanWithError:(NSError *)error
{
	[self breakWithError:error];
}

- (void)scannerDevice:(ICScannerDevice *)scanner didCompleteScanWithError:(NSError *)error;
{
	[self didCompleteScanWithError:error];
}

@end

@implementation ScannerBrowser

- (id)init
{
	if(!(self = [super init])) return self;
	
	_scanners = [[NSMutableArray alloc]initWithCapacity:0];
	
	return self;
}

- (void)dealloc
{
	[_scanners release];
	
	[super dealloc];
}

- (ICScannerDevice *)scannerForIdentifier:(NSString *)uuid
{
	ICScannerDevice *scanner = nil;
	if(uuid)
	{
		NSUInteger i = [_scanners indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
										{
											if ([[(ICDevice*)obj UUIDString] isEqualToString:uuid])
											{
												return YES;
											}
											return NO;
										}];
		
		if(NSNotFound != i)
		{
			scanner = [_scanners objectAtIndex:i];
		};
	}
	return scanner;
}

@synthesize scanners = _scanners;

#pragma mark ICDeviceBrowserDelegate

- (void)deviceBrowser:(ICDeviceBrowser *)browser didAddDevice:(ICDevice *)addedDevice moreComing:(BOOL)moreComing
{
	if([addedDevice isKindOfClass:[ICScannerDevice class]])
	{
		[_scanners addObject:addedDevice];
	}
}

- (void)deviceBrowser:(ICDeviceBrowser *)browser didRemoveDevice:(ICDevice *)device moreGoing:(BOOL)moreGoing
{
	
	NSUInteger i = [_scanners indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
									{
										if ([[(ICDevice*)obj UUIDString] isEqualToString:[device UUIDString]])
										{
											return YES;
										}
										return NO;
									}];
	
	if(NSNotFound != i)
	{
		[_scanners removeObjectAtIndex:i];
	};
}

@end

#endif

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
#if VERSIONMAC
	Scan::startDeviceBrowser();
	listenerLoopStart();
#endif
}

void OnExit()
{
#if VERSIONMAC
	Scan::cleanupWithTimeout(10);
	Scan::stopDeviceBrowser();
	listenerLoopFinish();
#endif
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
	}
	catch(...)
	{
		
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
			// --- ImageCaptureCore (macOS)
			
		case 1 :
			ICA_SCANNERS_LIST(pResult, pParams);
			break;
			
		case 2 :
			ICA_SET_SCAN_OPTION(pResult, pParams);
			break;
			
		case 3 :
			ICA_OPEN_SCANNER_SESSION(pResult, pParams);
			break;
			
		case 4 :
			ICA_CLOSE_SCANNER_SESSION(pResult, pParams);
			break;
			
		case 5 :
			ICA_SCAN(pResult, pParams);
			break;
			
		case 6 :
			ICA_CANCEL(pResult, pParams);
			break;
			
		case 7 :
			ICA_Get_scan_option(pResult, pParams);
			break;
			
	}
}

// --------------------------- ImageCaptureCore (macOS) ---------------------------

#pragma mark -

void ICA_SCANNERS_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1_scanners_list;
	
	Scan::getScanners(Param1_scanners_list);
	
	Param1_scanners_list.toParamAtIndex(pParams, 1);
}

void ICA_OPEN_SCANNER_SESSION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	C_LONGINT Param2_source;
	
	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	Param2_source.fromParamAtIndex(pParams, 2);
	
	ICScannerFunctionalUnitType scanner_source_type = (ICScannerFunctionalUnitType)Param2_source.getIntValue();
	
	Scan::openScanner(Param1_scanner_id, scanner_source_type);
}

void ICA_CLOSE_SCANNER_SESSION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	
	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	
	Scan::closeScanner(Param1_scanner_id);
}

void ICA_SCAN(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	C_TEXT Param2_callback;
	C_TEXT Param3_user_info;

	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	Param2_callback.fromParamAtIndex(pParams, 2);
	Param3_user_info.fromParamAtIndex(pParams, 3);
	
	Scan::setMethod(Param2_callback, Param3_user_info);
	
	Scan::runScanner(Param1_scanner_id);
}

void ICA_CANCEL(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	
	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	
	Scan::runScanner(Param1_scanner_id);
}

void ICA_SET_SCAN_OPTION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	C_LONGINT Param2_option;
	C_TEXT Param3_value;
	
	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	Param2_option.fromParamAtIndex(pParams, 2);
	Param3_value.fromParamAtIndex(pParams, 3);
	
	Scan::setOption(Param1_scanner_id, Param2_option, Param3_value);
}

void ICA_Get_scan_option(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner_id;
	C_LONGINT Param2_option;
	C_TEXT returnValue;

	Param1_scanner_id.fromParamAtIndex(pParams, 1);
	Param2_option.fromParamAtIndex(pParams, 2);

	Scan::getOption(Param1_scanner_id, Param2_option, returnValue);

	returnValue.setReturn(pResult);
}


